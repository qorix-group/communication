/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
package Communication

import ScoreReq

section "LoLa" {

    // ID: 6366726
    ScoreReq.FailureMode InMemoryConfigurationWrong {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "The in-memory (cpp representation) does not match the on file-system JSON configuration."
        failureeffect = "Other functionality relies on a correct configuration. Without that, multiple functions can not operate normally which could lead to the violation of a safety goal."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "The wrong user-configuration which could cause an abnormal behavior of the mw-implementation is covered via four AoUs. The broken file is ensured via a safety-certified file system. The broken JSON is covered via a safety-certified JSON-Parser implementation. The read-in-logic to our in-memory is covered via a specific preventive measure."
        interface = "mw.com.Runtime.Initialize"
    }

    // ID: 6165662
    ScoreReq.FailureMode CreationOfSkeletonNotPossible {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "It is not possible to create a skeleton instance"
        failureeffect = "No communication possible."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "We added an AoU that no Safety-goal shall be harmed, if a service is not offered. Thus, this failure cannot have any safety-related bad effect."
        interface = "mw.com.Skeleton.Create"
    }

    // ID: 31544607
    ScoreReq.FailureMode ServiceOfferedWithoutInitialFieldValue {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "A service is offered, although at least one of its field has no initial value set by the provider."
        failureeffect = "A user expects after seeing a service offered, in a call to GetNewSamples(), that he would at least get one new sample. This could hinder the expected semantics on user side, and thus affect any safety goal."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "By explicitly requesting this case in our requirements and testing the requirement we make sure that the error case is tackled. The not working update functionality is covered already by other FMEA elements in Section SendAnEventOrField"
        interface = "mw.com.Skeleton.OfferService"
    }

    // ID: 6156955
    ScoreReq.FailureMode ServiceNotOffered {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "A skeleton service is offering a service, but the service is silently not offered. Note: offered in this case means, that it is also connectable"
        failureeffect = "No communication between process will happen, thus no information can be exchanged, thus any overall system functionality can stop."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "We added an AoU that no Safety-goal shall be harmed, if a service is not offered. Thus, this failure cannot have any safety-related bad effect."
        interface = "mw.com.Skeleton.OfferService"
    }

    // ID: 6164063
    ScoreReq.FailureMode ServiceOfferedOnWrongBinding {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "A skeleton is offering a service on the wrong binding. Meaning, the service is not offered on the intended binding, but on an unintended one."
        failureeffect = "No communication between processes will happen, thus, no information can be exchanged, thus, any overall system functionality can malfunction. The point that a service is offered on another binding should not have any effect, since no consumer will expect the service on this binding."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "If a service is offered on the wrong binding, then it will not be visible on the expected binding. Thus, we can handle this part as if the service would not be offered at all. For the wrong binding, where the service is offered, no consumer expects the service, thus, no bad influence can happen."
        interface = "mw.com.Skeleton.OfferService"
    }

    // ID: 6164070
    ScoreReq.FailureMode ServiceOfferedUnderWrongIds {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "A skeleton is offering a service with wrong identifiers. This can include a service id, a instance id or also the service version."
        failureeffect = "The actual intended communication will not happen, thus potential causing a complete loss of system functionality. In the worst case, the wrong identifiers are used by another service. In that case a wrong consumer could think that he found the right service, leading to a case where garbage data is transmitted, causing any potential issues in the whole system functionality (e.g. violating the top level safety goal)."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "If a service is offered on a wrong binding, then the initial service is not offered. Covered by our AoU (\"No guarantee in availability of services\"). It looks different if we overwrite this way another service. This is prevented with explicit preventive measures for each root cause. The Service Discovery Marker files are already handled in the failure mode \"ServiceNotOffered\""
        interface = "mw.com.Skeleton.OfferService"
    }

    // ID: 6164082
    ScoreReq.FailureMode OffersAlreadyOfferedService {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "A skeleton offers a service that was already offered. Either by another process or by itself."
        failureeffect = "Already existing communication could break up. Or data could be overwritten while transmitted. In any case this could cause potential garbage data, which could cause a complete malfunction of the system."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "We avoid to overwrite shared memory segments of different processes by having ownership by a single UID which is assigned to a process. (This was in place before the FMEA) In addition we support partial restart, which is implemented and traced according to ASIL-B which enables to re-offer a previously offered service in a sane manner. To identify already offered services, control measures via marker files have been introduced."
        interface = "mw.com.Skeleton.OfferService"
    }

    // ID: 6164086
    ScoreReq.FailureMode ServiceOnlyPartiallyOffered {
        guideword = ScoreReq.GuideWord.PartialFunction
        description = "A skeleton offers a service, which is not visible to all consumers, but only to parts of them."
        failureeffect = "This is equal to the case service not offered, thus no information can be exchanged, thus any overall system functionality can stop."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Since both sub-trees (config is wrong, no ASIL level) are captured via different fault trees, we only need to ensure that all events are actually always registered. This is ensured via an preventive measure."
        interface = "mw.com.Skeleton.OfferService"
    }

    // ID: 6164171
    ScoreReq.FailureMode ServiceOnlyPartiallyStopOffered {
        guideword = ScoreReq.GuideWord.PartialFunction
        description = "A skeleton stop offers a service, but the service is still seen a partial set of consumers."
        failureeffect = "A service is found by a consumer, even though it shall no longer be found. This shall have no bad influence, since then no data will be send."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Since we agreed on not harming a safety goal on the sudden death of an producer, a partial stop offer (which could be part of a sudden death) can not have any bad effect."
        interface = "mw.com.Skeleton.StopOfferService"
    }

    // ID: 6164217
    ScoreReq.FailureMode ServiceStopOfferingWrongIds {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "A skeleton is stop offering a service under wrong IDs. This can include a service id, a instance id or also the service version."
        failureeffect = "A wrong service is stop offered. This means that another service might no longer be found, even though it should be found. It could also cause garbage data, depending on the service discovery mechanism. This could cause a complete loss of functionality and influence customer functions"
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "If a service is stopped on the wrong id, that means that another service is no longer found (AoU existing). The case is that our service is not stopped it all (already covered by second AoU)."
        interface = "mw.com.Skeleton.StopOfferService"
    }

    // ID: 6164265
    ScoreReq.FailureMode MemoryAllocatedInWrongSection {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "The memory for an event is allocated in the wrong memory section (e.g. in Heap, another Shared Memory segment or the stack)."
        failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Any user faults are covered by the AoU, that no user provided types shall be used with the mw::com. The following faults * \"Middleware provided type is wrong\" * \"Shared memory resource not forwarded\" * \"Shared Memory Factory returns wrong memory resource\" * \"Shared Memory resource returns wrong proxy\" * \"Forwarded wrong shared memory segment from the beginning\" * \"Shared Memory Resource opens wrong shared memory segment\" * Stack allocations are prevented by ensure correct working functionality assigned by single requirements. ProxyID overwritten is the most critical part, which needs another safety mechanism. An accidentally overwrite will be covered by additional checks (e.g. CRC). An OffsetPTR corruption would be covered by our active bound checking, so this is no new issue that could occur."
    }

    // ID: 6164791
    ScoreReq.FailureMode TooFewMemoryAllocated {
        guideword = ScoreReq.GuideWord.PartialFunction
        description = "The event allocation allocates too few memory (including no memory at all)."
        failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "1. \"Literally wrong number of slots reserved\": Covered by preventive measure \"reserve configured number of slots\" 2. \"More than one SampleAllocateePtr in parallel\": Covered by AoUs (\"one producer, one allocatee ptr\", \"no-copy on send, while holding allocatee ptr\", since copy-send calls allocate implicitly) 3. \"Holds more sample ptr than announced\": Covered by \"a proxy instance shall not retrieve more sample ptr...\" 4. \"Holds more sample ptr than configured\": Covered by AoUs (\"configured maximum number of subscriber\", \" configured maximum number of elements\") 5. \"slot allocation logic broken\": Covered by \"Slot allocation synchronisation\" 6. \"Mapping of wrong EventId\": Covered by \"EventFqId shall be constructed from the associated configuration values\" 7. \"Shared memory truncation fails\": Is controlled by \" A process shall terminate, if the truncation of a shared memory segment fails.\" by transitioning into a safe state. 8. The necessary size calculation cannot fail, since it is just a sizeof() 9. \"Allocate claims to few memory\": Is covered by \"SharedMemoryResource shall allocate the requested memory on an allocate call\" Note: A Proxy can either be a \"regular\" proxy, or an \"ipc tracing\" proxy."
        interface = "mw.com.Event.Allocate"
    }

    // ID: 6164966
    ScoreReq.FailureMode SendingEventChangesUserData {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "A call to send manipulates the data that was provided by the caller."
        failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Most of the possible errors have been discussed with [ISSUE:Failuremode TooFewMemoryAllocated]. The issue with the generic trace API is covered by its custom preventive measure. Only the direct manipulation is a net yet covered possible fault cause. Which is addressed with our preventive measure."
        interface = "mw.com.Event.Send"
    }

    // ID: 6164996
    ScoreReq.FailureMode SendingEventOnlyPartiallyNotifiesConsumer {
        guideword = ScoreReq.GuideWord.PartialFunction
        description = "When data is sent, consumers that have a callback registered, are only partially notified."
        failureeffect = "This could cause that data is not processed, causing a complete outage of the system. In the worst case the safety goal could be violated."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Our AoU states that the fault shall not cause safety goal violations. Thus, no additional measures are required."
        interface = "mw.com.Event.Send"
    }

    // ID: 6165326
    ScoreReq.FailureMode SendingEventSendsToWrongConsumer {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "An event or field is sent to the wrong consumer."
        failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "All possible fault causes are already addressed with [ISSUE:Failuremode TooFewMemoryAllocated]"
        interface = "mw.com.Event.Send"
    }

    // ID: 6165624
    ScoreReq.FailureMode SendingEventDoesNotFreeResources {
        guideword = ScoreReq.GuideWord.PartialFunction
        description = "Resources in the middleware that have been allocated with a previous allocation, are not freed after returning from send/update."
        failureeffect = "This could lead to a resource exhaustion of the system. Leading to a situation where no communication would be possible."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "All three steps that could fail during freeing the resources are prevented by their respective requirements."
        interface = "mw.com.Event.Send"
    }

    // ID: 6165759
    ScoreReq.FailureMode WrongResourcesFreed {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "A destruction of one skeleton instances, frees the resources of another skeleton instance."
        failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "A wrong freeing of resources would only be possible by a wrong holding of resources, which is avoided by our two preventive measures."
        interface = "mw.com.Skeleton.Destroy"
    }

    // ID: 6165782
    ScoreReq.FailureMode NoResourcesFreed {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "The resources allocated on construction and during operation are not freed on destruction."
        failureeffect = "Can cause an overall resource exhaustion."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Another safety argument is added that shall avoid that no resources are freed."
        interface = "mw.com.Skeleton.Destroy"
    }

    // ID: 31546222
    ScoreReq.FailureMode StartFindServiceCallbackCalledUnexpectedly {
        guideword = ScoreReq.GuideWord.ExceedingFunction
        description = "The user-provided callback is invoked, even though it should not be invoked."
        failureeffect = "In the worst case, the callback is invoked all the time, which could lead to: The user thinks that a new proxy is found and creates a proxy with an already used handle; A DDoS is performed, where one thread is constantly blocked. Both can lead to violations of safety goals."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Called even though StopFindService has been called, is tackled by the preventive measure: Proxy StopFindService. Called redundantly, is tackled by the preventive measure: \"Invoke FindServiceHandler...\" Wrong inotify events, are impossible, since these come from the OS, which is safety certified (no restriction found in the safety manual). Watches are set wrongly, is tackled by our preventive measure: Correct watches per Instance Identifier"
        interface = "mw.com.Proxy.StartFindService"
    }

    // ID: 6166029
    ScoreReq.FailureMode ServiceNotFound {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "A proxy does not find a service instance, even though it was offered by a skeleton."
        failureeffect = "No communication between process will happen, thus no information can be exchanged, thus any overall system functionality can stop."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = ""
        interface = "mw.com.Proxy.FindService"
    }

    // ID: 6166047
    ScoreReq.FailureMode WrongServiceFound {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "A proxy instance finds a wrong service. This could be either a wrong service instance or a completely wrong service."
        failureeffect = "The actual intended communication will not happen, thus potential causing a complete loss of system functionality. In the worst case, the wrong identifiers are used by another service. In that case a wrong consumer could think that he found the right service, leading to a case where garbage data is transmitted, causing any potential issues in the whole system functionality (e.g. violating the top level safety goal)."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Both faults of wrongly configured and offered under wrong service IDs are covered by other analysis (Failuremode ServiceOfferedUnderWrongIds). For the InstanceSpecifier to Identifier we have the preventive measure \"InstanceSpecifier resolution can not retrieve wrong InstanceIdentifier resolution can not retrieve wrong InstanceIdentifier The last fault is covered by the ensured correct mapping of InstanceIdentifier to path."
        interface = "mw.com.Proxy.FindService"
    }

    // ID: 6166060
    ScoreReq.FailureMode ServiceIsFoundButDoesNotExist {
        guideword = ScoreReq.GuideWord.ExceedingFunction
        description = "Finding a service, returns a service, even though no service instance was offered."
        failureeffect = "No communication between process will happen, thus no information can be exchanged, thus any overall system functionality can stop."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "The first root cause cannot happen, since otherwise the Operating System would make stupid stuff. mmap will not map any memory if a file does not exist. \"Service was offered, but not unlinked on stop offer\", is covered by our AoU that we do not notify on termination of the provider side. The other three faults are covered by the two preventive measures."
        interface = "mw.com.Proxy.FindService"
    }

    // ID: 31545522
    ScoreReq.FailureMode TheSizeReturnedIsBiggerThenTheActualValue {
        guideword = ScoreReq.GuideWord.ExceedingFunction
        description = "The user receives a size, that is bigger then the actual value."
        failureeffect = "Undefined behavior due to wrong memory access."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "A manipulated size is tackled, by \"Size information in read-only memory\". The right location is ensured via \"Location of type-meta-information information for Generic Proxy\" The wrong set size, is covered by \"The type-meta-information shall be calculated based on the provided event/field type"
        interface = "mw.com.GenericProxyEvent.GetSampleSize"
    }

    // ID: 31545538
    ScoreReq.FailureMode TheSizeReturnedIsSmallerThenTheActualSize {
        guideword = ScoreReq.GuideWord.PartialFunction
        description = "The user receives a size, that is smaller then the actual value."
        failureeffect = "Only seeing a subset of the data, thus a potential violation of any safety goal."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Potential faults and measures are the same as [ISSUE:Failuremode TheSizeReturnedIsBiggerThenTheActualValue]"
        potentialcause = "Same as [ISSUE:Failuremode TheSizeReturnedIsBiggerThenTheActualValue]"
        interface = "mw.com.GenericProxyEvent.GetSampleSize"
    }

    // ID: 31545581
    ScoreReq.FailureMode WrongIndicationIfFormatIsSerialized {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "A user, using HasSerializedFormat(), receives the wrong value."
        failureeffect = "Missinterpretation of data, can lead to any safety violation."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Hard-coded value, not faults possible."
        potentialcause = "Hard-coded value, no faults possible."
        interface = "mw.com.GenericProxyEvent.HasSerializedFormat"
    }

    // ID: 31551259
    ScoreReq.FailureMode NotEnoughMemoryToAllocate {
        guideword = ScoreReq.GuideWord.LossOfFunction
        description = "Memory for an event or field can not be allocated, because the underlying memory resource is exhausted."
        failureeffect = "N/A"
        version = 1
        safety = ScoreReq.Asil.B
    }

    // ID: 6166260
    ScoreReq.FailureMode SubscribesViaWrongAsilChannel {
        guideword = ScoreReq.GuideWord.PartialFunction
        description = "A proxy uses wrong subscription channel (QM instead of ASIL-B)."
        failureeffect = "A subscription might no reach the producer causing the same effects as described in ."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "This issue can only happen due to a wrong selection of paths in message passing itself. This cases are already covered on the \"not subscribe\" part, mentioned."
        potentialcause = "Same error root causes as in [ISSUE:FailureMode DoesNotSubscribe]"
    }

    // ID: 6165713
    ScoreReq.FailureMode AnyFunctionBlocksLongerThanExpected {
        guideword = ScoreReq.GuideWord.DelayedFunction
        description = "Any API of mw::com (LoLa) blocks longer than expected (or indefinite)"
        failureeffect = "This could cause a hold of parts or the whole system."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Our system anyhow imposes a watchdog to check for safety-related and time related paths. Thus, we do not try to safety qualify ever aspect and guarantee any execution timings."
        potentialcause = "e.g. - Blocked mutex (e.g. dead-lock) - Wrong synchronization algorithm - endless loop - crashed services"
    }

    // ID: 6370893
    ScoreReq.FailureMode FunctionCalledFromMultipleThreads {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "Any API is called within multiple threads concurrently without any further synchronization."
        failureeffect = "This can lead to race-conditions which can cause data-corruption or data-loss, which could lead to a violation of any safety goal."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Latter is covered via our AoU. If a user wants to access a proxy/skeleton from multiple threads, he shall either implement a custom synchronization, or treat it as custom instance."
        potentialcause = "- static methods are thread-safe - API calls on different instances are thread-safe - API calls on one instance are not thread-safe."
    }

    // ID: 6370898
    ScoreReq.FailureMode GeneratedCodeDoesNotMatchGenerationInputs {
        guideword = ScoreReq.GuideWord.UnintendedFunction
        description = "Proxys and Skeletons as data-types are generated using the aragen and not handwritten, may not match to the input (Meta-Model)."
        failureeffect = "A faulty configuration which does not lead to compile issues could lead to safety issues according to analysis."
        version = 1
        safety = ScoreReq.Asil.B
        rationale = "Add an AoU that all configurations should be reviewed before use in a safety context."
        potentialcause = "aragen was not implemented according to safety standards and no code-review or safety analysis was performed. Thus any potential issue could happen."
    }

    section "Skeleton" {

        section "Creation" {

            // ID: 6370915
            ScoreReq.FailureMode MisusedApis {
                guideword = ScoreReq.GuideWord.ExceedingFunction
                description = "APIs are invoked in either an invalid context or non public APIs are invoked."
                failureeffect = "Calling non-public APIs or calling them in the wrong context can lead to un-predictable side-effects. This could cause in the worst case transmitting garbage data, which could cause a violation of any safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Each potential cause is covered with a custom AoU."
                potentialcause = "Potential causes are: - calling APIs of implementation namespace (aka implementation details, thus avoiding public contracts) - Invoking APIs from static context (aka static lifetime) -> can cause issues with static initialization - Using a different operating system as design for (different underlying AoUs and safety measures) - Throwing callbacks could lead to untested code-paths."
            }

        }

        section "OfferAService" {

            // ID: 6164141
            ScoreReq.FailureMode ServiceOfferingNotStopped {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "A skeleton offered a service, but the stop offering did not work."
                failureeffect = "A service is found by a consumer, even though it shall no longer be found. This shall have no bad influence, since then no data will be send."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "A sudden death of a producer also does not follow the stop offer service protocol. Thus, the service is still available, but no events are sent. Stop Offer service is a strict subset of the sudden death of a producer, therefor this case is covered by the mentioned AoU."
            }

            // ID: 6164197
            ScoreReq.FailureMode ServiceStopOfferedOnWrongBinding {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A skeleton is stop offering a service on the wrong binding. Meaning, the service is still offered on the actual binding."
                failureeffect = "A service is found by a consumer, even though it shall no longer be found. This shall have no bad influence, since then no data will be send. On the other (wrong) binding, no effect will happen, since the service was never offered here anyhow."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Same as Failuremode ServiceOfferingNotStopped"
                potentialcause = "Same as Failuremode ServiceOfferingNotStopped"
            }

            // ID: 6164809
            ScoreReq.FailureMode WronglyAlignedMemoryAllocated {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "The memory for an event/field is allocated in a wrongly aligned manner."
                failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "We ensure with our preventive measure that wrong alignment could happen."
                potentialcause = "This issue can only happen if the alignment calculation within the SharedMemoryResource fails."
            }

        }

        section "StopOfferAService" {

            // ID: 6164821
            ScoreReq.FailureMode TooMuchMemoryAllocated {
                guideword = ScoreReq.GuideWord.ExceedingFunction
                description = "There is too much memory allocated for one event/field"
                failureeffect = "While to much memory has no immediate bad effect, this could cause an overall resource exhaustion within the system."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Basically the same faults and reactions as on [ISSUE:Failuremode TooFewMemoryAllocated] apply. There is no benefit to duplicate all the information also within this fault"
                potentialcause = "The possible causes are the same as [ISSUE:Failuremode TooFewMemoryAllocated]"
            }

            // ID: 6164832
            ScoreReq.FailureMode AllocatesAlreadyAllocatedMemory {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "The memory for an event/field is allocated from already allocated memory (not free memory)."
                failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Our preventive measure ensure that the allocation within a Shared Memory Resource works as expected."
                potentialcause = "The only possibility is a mistake in the allocation strategy of a Shared Memory Resource."
            }

            // ID: 6164982
            ScoreReq.FailureMode SendingAnEventOrFieldSendsDataOnlyPartially {
                guideword = ScoreReq.GuideWord.PartialFunction
                description = "Data that is send by the user, only reaches partially the consumer. This can happen in two ways, only a partial number of consumers see the data or all consumers see only partial data."
                failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "issue not possible with current design. no additional measures required."
                potentialcause = "This issue cannot happen. If then it is a memory allocation topic and covered by [ISSUE:Failuremode TooFewMemoryAllocated]"
            }

        }

        section "AllocateAnEventOrField" {

            // ID: 6165344
            ScoreReq.FailureMode SendingAnEventOrFieldSendsSameSampleNtimes {
                guideword = ScoreReq.GuideWord.ExceedingFunction
                description = "Instead of sending a sample (one data point) only once, it is send multiple times."
                failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "The only possible fault cause is eliminated with our preventive measure."
                potentialcause = "The only possibility that this happens is on copy-on send. For that copy-on send would need to call allocate multiple times."
            }

            // ID: 6165797
            ScoreReq.FailureMode EarlyCleanUp {
                guideword = ScoreReq.GuideWord.ExceedingFunction
                description = "Resources are freed while still being used."
                failureeffect = "This could cause transmitting garbage data between processes, causing a complete outage of the system. In the worst case the safety goal could be violated."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "By only freeing resources on destruction, we can avoid early resource clean ups."
                potentialcause = "nearly the same as [ISSUE:Failuremode NoResourcesFreed] The only difference is that unlink / unmap will happen early."
            }

        }

        section "SendAnEventOrField" {

            // ID: 31546507
            ScoreReq.FailureMode StartedFindServiceIsNotStopped {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "A user called \"StartFindService\" with a given handler, and since \"StopFindService\" does not work, services can still be found."
                failureeffect = "StartFindService handler will be called, even though it is expected that it is not called."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "With the preventive measure, we ensure that this cannot happen."
                potentialcause = "These cases are basically already covered here: [ISSUE:Failuremode StartFindServiceCallbackCalledUnexpectedly]"
            }

            // ID: 31546514
            ScoreReq.FailureMode WrongStartfindserviceIsStopped {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "The handle provided to StopFindService, is identified as another one and thus stops the wrong service discovery query."
                failureeffect = "That services are not found, even though they are offered and that services are no longer offered."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Both potential effects are made clear to our customers via AoUs and is thus expected."
                potentialcause = "Messed up handling of handles (only possibility, no tree needed)"
            }

        }

        section "Destruction" {

            // ID: 6166213
            ScoreReq.FailureMode SubscribeToWrongEvent {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A service proxy subscribes to a wrong event. This either means that this event does not exist at all, is offered by another service instance, another event in the current instance or a completely different service."
                failureeffect = "It is possible to allocate resources on another event and therefor block another valid subscription to this event. This could cause in the worst case that an safety relevant event cannot receive data, thus harming overall safety goals. Another case is that garbage data is transmitted / received. Causing any possible side-effect."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "All four root causes have been prevented by according measures each. * The name mapping clash in case of a GenericProxy is prevented by: ''Service-Element-Name clash needs to get unambigiously detected.'' * The referencing of wrong storage location is prevented by: ''Mapping from Event/Field identification to shared-memory storage needs to be unambigous.''"
            }

            // ID: 6166218
            ScoreReq.FailureMode SubscribeWithWrongMaxSampleCount {
                guideword = ScoreReq.GuideWord.PartialFunction
                description = "A proxy instance subscribes to an event to with a wrong sample count, meaning a different one that was provided by the user."
                failureeffect = "We have two possible effects: First if the number is lower then expected data of the user might be lost unexpectedly. Causing any possible side-effects. If its bigger, we could blocker other receiver which then get to few resources. Or the subscription fails at all. In the first two cases a possible safety goal violation could happen by not transmitting safety relevant data reliably."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Both possible root cause are checked with preventive measures."
            }

        }

    }

    section "Proxy" {

        section "FindService" {

            // ID: 6166225
            ScoreReq.FailureMode DoesNotSubscribe {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "A proxy does not subscribe to a skeleton. Thus, a skeleton does not know that a proxy is interested in data."
                failureeffect = "A proxy will not be notified over new data. - This will lead to subscription state not changing to subscribed. And therefor a client application will not be able to access samples. This will lead to not receiving any safety relevant information, causing any possible safety goal violation. - Necessary resources might be blocked even though they are not reserved, causing potential blocks of other subscribers."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "-"
                potentialcause = "the only possible fault is, that the shared memory segment or event is wrongly choosen, but this was already checked before while creating, so this can not really happen."
            }

            // ID: 6166297
            ScoreReq.FailureMode ReceiveHandlerNotInvoked {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "A proxy has set a receive handler and a skeleton is updating an event, but the receive handler is never invoked."
                failureeffect = "It is possible that no event data is received ever and thus any safety issues are possible."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "N/A because root-cause covered by AoU."
                potentialcause = "N/A because root-cause covered by AoU."
            }

        }

        section "SubscribeForAnEvent" {

            // ID: 6166301
            ScoreReq.FailureMode ReceiveHandlerInvokedWithWrongEvent {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A receive handler registered for an event, gets called because of an update of an different event."
                failureeffect = "The only implication that this has are resource wise on timing. So a always notified handler could block one thread and thus make the overall system way more slow. The safety concept of the whole system supervises timely violations and ensures that no safety goal is harmed."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = ""
            }

            // ID: 6166306
            ScoreReq.FailureMode ReceiveHandlerInvokedMultipleTimes {
                guideword = ScoreReq.GuideWord.ExceedingFunction
                description = "A receive handler is invoked multiple times, even though only one event update happend."
                failureeffect = "The only implication that this has are ressource wise on timing. So a always notified handler could block one thread and thus make the overall system way more slow. The safety concept of the whole system supervises timely violations and ensures that no safety goal is harmed."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "N/A because root-cause covered by AoU."
                potentialcause = "N/A because root-cause covered by AoU."
            }

            // ID: 6166310
            ScoreReq.FailureMode ReceiveHandlerInvokedWithoutEventNotification {
                guideword = ScoreReq.GuideWord.ExceedingFunction
                description = "A receive handler is invoked, even though no event update happend."
                failureeffect = "A receive handler is invoked, even though no new events are available. The only implication that this has are ressource wise on timing. So a always notified handler could block one thread and thus make the overall system way more slow."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "N/A because root-cause covered by AoU."
                potentialcause = "N/A because root-cause covered by AoU."
            }

        }

        section "SetReceiveHandler" {

            // ID: 6166331
            ScoreReq.FailureMode CallbackNotInvokedDespiteSamplesAvailable {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "GetNewSamples() gets called on an event with a callback F, but the callback gets called not at all, although at least one new sample is available."
                failureeffect = "data is not received, causing any possible safety goal violation."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "The wrong values are systematic faults wich are prevented using a correct slot allocation strategy. The overwrite of shared memory data was already built into the original design and can only happen if processes are started using wrong users, which is avoided using our AoU."
            }

            // ID: 6166345
            ScoreReq.FailureMode CallbackInvokedWithWrongData {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A proxy receives a sample pointer via callback F(), but the data does not contain the expected one."
                failureeffect = "processing of invalid data can cause any safety violation (e.g. violation of the top level safety goal)"
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "All possible faults, have either assigned a preventive measure or respective AoUs."
            }

            // ID: 6166350
            ScoreReq.FailureMode UsesToManySampleptr {
                guideword = ScoreReq.GuideWord.ExceedingFunction
                description = "User is already max. sample count SamplePtr, but we are still handing out SamplePtrs in callback F()."
                failureeffect = "Synchronization algorithm can no longer hold guarantees, which can cause an exceeding of resources. In worst case another proxy might fail to get updated samples (messages lost without full queues aka not detectable)."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "The only possibility for this failure mode is actively covered by our preventive measure."
                potentialcause = "Reference Counting facility for SamplePtr is broken. Either: - storage or current count - increment logic - decrement logic"
            }

            // ID: 6166353
            ScoreReq.FailureMode ReturnsWrongSampleCount {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "Value returned by GetNewSample() does not match with the number of calls to callback F()."
                failureeffect = "Potential Data loss with unknown effect on safety goals."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Single systematic failure is covered by single preventive measure."
                potentialcause = "The counter of invoked callbacks is wrong."
            }

            // ID: 6166357
            ScoreReq.FailureMode SucceedsDespiteAnError {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A user calls GetNewSamples() on a proxy instance and receives a sample count, even though he should have received an error."
                failureeffect = "Receive a sample count instead of an error, implies that the sample count is wrong. Receiving an error instead of a sample count, implies that the sample count is wrong."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Same as [ISSUE:FailureMode ReturnsWrongSampleCount]"
                potentialcause = "Same as [ISSUE:FailureMode ReturnsWrongSampleCount]"
                interface = "mw.com.Event.GetNewSamples"
            }

        }

        section "GetNewSamples" {

            // ID: 6166359
            ScoreReq.FailureMode ReturnsWrongFreeSampleCount {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A user has already M SamplePtr in use from a max. announced number N, but GetFreeSampleCount() returns a different value than N-M."
                failureeffect = "It would be no longer possible to detect message losses on full queues."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "The correct implementation of GetFreeSampleCount() and of SamplePtr freeing of resources can only be tested together. Thus, both parts are covered via the same preventive measure."
                potentialcause = "Internal counter of free and used samples broken."
            }

            // ID: 6166363
            ScoreReq.FailureMode DoesNotUnsubscribe {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "A proxy is subscribed to an event, tries to unsubscribe, but silently fails to unsubscribe."
                failureeffect = "Resource blockage on new subscriptions on other consumers. Maybe no communication possible."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Message transmission failed, indicates an issue in our message passing library, which was already analyzed in [ISSUE:FailureMode SubscribeToWrongEvent] A proxy crash is not explicitly supported, with our partial restart feature."
            }

            // ID: 6166364
            ScoreReq.FailureMode UnsubscribesFromWrongEvent {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A user unsubscribes from an event, but the unsubscribe is silently carried out on another event."
                failureeffect = "Same as Failuremode SubscribeToWrongEvent"
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "If we unsubscribe to an wrong event, basically the same situation arises as if we would subscribe to a wrong event."
                potentialcause = "Same as [ISSUE:Failuremode SubscribeToWrongEvent]"
            }

        }

        section "GetFreeSampleCount" {

            // ID: 6166365
            ScoreReq.FailureMode DoesNotImplicitRemoveReceiveHandler {
                guideword = ScoreReq.GuideWord.PartialFunction
                description = "A proxy has registered a receive handler and unsubscribes, this should lead to the case that a receive handler is no longer called. In this failure mode, the receive handler would still be called."
                failureeffect = "Invocation of invalid receive handler, because it no longer exists. This could have any bad potential side effects."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Only one possible failure that is covered with a preventive measure."
                potentialcause = "Only possible fault is that the receive handler is not removed on unsubscription."
            }

            // ID: 31545325
            ScoreReq.FailureMode MapContainingNonexistentEvents {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "The map that is visible to the user, contains events that are not actually existing (e.g. in the configuration)."
                failureeffect = "A user could take wrong actions based on this information and thus affect any safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Can only happen, if user misconfigures the system."
            }

            // ID: 31545231
            ScoreReq.FailureMode IncompleteMapOfEvents {
                guideword = ScoreReq.GuideWord.PartialFunction
                description = "The user gets presented not all events the generic proxy supports."
                failureeffect = "Due to the map not complete, this will lead to missed data, because the user is not aware that these events are actually there. This could affect any safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Special case of [ISSUE:Failuremode MapContainingNonexistentEvents]"
                potentialcause = "Same as [ISSUE:Failuremode MapContainingNonexistentEvents]"
            }

        }

        section "Unsubscribe" {

            // ID: 6166375
            ScoreReq.FailureMode DoesNotFreeResourcesOnDestruction {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "A SampleAllocateePtr or SamplePtr is destroyed, which should lead to a freeing of resources, but caused by a fault they are not freed."
                failureeffect = "Resource exhaustion. Could block further communication which could lead to failures on provider and consumer side, which on the other hand could lead to a violation of a safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "This failure mode can be avoided by ensuring an always valid slot and ensuring a correct slot-change logic. Which both is presented as preventive measure."
            }

            // ID: 6166378
            ScoreReq.FailureMode FreesWrongResources {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "A SampleAllocateePtr or SamplePtr free the wrong resources associated with them."
                failureeffect = "Communication of data-garbage or resource exhaustion, which both could harm an overall safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Same as [ISSUE:Failuremode DoesNotFreeResourcesOnDestruction]"
                potentialcause = "Same as [ISSUE:Failuremode DoesNotFreeResourcesOnDestruction] with the only difference that a slot could now be valid but the wrong one."
            }

            // ID: 6166381
            ScoreReq.FailureMode DoesNotReserveResources {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "A SamplePtr or SampleAllocateePtr do not increase their respective ref-counts and thus avoid data changes."
                failureeffect = "Data is manipulated from different processes because they think its not owned. Which could cause garbage data and thus harm any safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "Same as [ISSUE:FailureMode DoesNotFreeResourcesOnDestruction] since a decrease of the ref-count has the same issues as an increas."
                potentialcause = "Same as [ISSUE:Failuremode DoesNotFreeResourcesOnDestruction]"
            }

            // ID: 6166382
            ScoreReq.FailureMode DoesNotUpdateFreeSampleCountCorrectly {
                guideword = ScoreReq.GuideWord.LossOfFunction
                description = "When a SamplePtr gets created or destroyed for a given event instance, the Free Sample Count of this instance doesn't get updated accordingly"
                failureeffect = "Users may not know, if they are allowed to retrieve new Samples at all and may therefore fail to get new data! This may violate any safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "By ensuring a correct behavior of the SamplePtr, this fault can be omitted."
                potentialcause = "The only possible cause is a wrong behavior of our reference counting mechanism."
            }

        }

        section "SmartPointer" {

            // ID: 6166385
            ScoreReq.FailureMode ReturnsWrongData {
                guideword = ScoreReq.GuideWord.UnintendedFunction
                description = "On dereferenciation of a SamplePtr or SampleAllocateePtr wrong data is returned."
                failureeffect = "If you cannot trust the data in the smart pointer, then the data can be garbage, which could break safe communication, which could harm any safety goal."
                version = 1
                safety = ScoreReq.Asil.B
                rationale = "The validity of the slot is ensured by a preventive measure, while the validity of the memory data is ensure by AoUs."
            }

        }

    }

}
