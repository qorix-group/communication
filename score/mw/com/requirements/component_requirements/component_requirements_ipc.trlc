/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/
package Communication

import ScoreReq

section "com" {

    section "Public_API_Specification" {

        section "Skeleton" {

            section "Functionality" {

            /* broken_link_c/issue/17412229 */
            ScoreReq.CompReq SkeletonClass {
                description = '''A {{Skeleton}} class shall be based on a specific service interface definition.

                Such a class may be generated by a code generator emitting C++ code at pre-compile-time, which gets an service interface definition as input in the form of an IDL (like arxml, fidl, syml).

                Or it may be generated at compile-time based on a service interface definition in the form of a C++ type definition with the help of C++ templates, which drive the generation.

                The class name and {{namespace}} of such a {{class}} is not fixed and decided in the generation step (see above).

                Note: {{Skeleton}} is the name used for the created Skeleton in subsequent requirements.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.CommunicationInterfaces@1, Communication.SupportForMultipleProgrammingLanguages@1]
                version = 1
            }

            /* broken_link_c/issue/22801577 */
            ScoreReq.CompReq SkeletonClassEventMembers {
                description = '''For each event the service interface definition contains, from which the Skeleton Class has been generated, it shall have a {{public}} member variable:

                * with a name equal to the name of the event in the underlying service interface definition.

                * with a type providing the features required in Skeleton Event'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.EventType@1, Communication.SupportForDataDrivenArchitecture@1, Communication.CommunicationInterfaces@1]
                version = 1
            }

            /* broken_link_c/issue/22801854 */
            ScoreReq.CompReq SkeletonClassFieldMembers {
                description = '''For each field the service interface definition contains, from which the Skeleton Class has been generated, it shall have a {{public}} member variable:

                * with a name equal to the name of the field in the underlying service interface definition.

                * with a type providing the features required in SkeletonField'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.CommunicationInterfaces@1, Communication.SupportForDataDrivenArchitecture@1]
                version = 1
            }

            /* broken_link_c/issue/22802065 */
            ScoreReq.CompReq SkeletonClassMethodMembers {
                description = '''For each service method the service interface definition contains, from which the Skeleton Class has been generated, it shall have a {{public}} member function:

                * with a name equal to the name of the method in the underlying service interface definition.

                * which is pure virtual

                * with return value and arguments according to: TBD'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForRequestDrivenArchitecture@1, Communication.Method@1, Communication.CommunicationInterfaces@1]
                version = 1
            }

            /* broken_link_c/issue/21266550 */
            ScoreReq.CompReq SkeletonConstructor {
                description = '''Construction of a {{Skeleton}} instance by the user shall only be possible via one of the public static {{Create()}} methods (See Skeleton Exception-less creation with Instance Specifier and Skeleton Exception-less creation with Instance ID).

                Therefore the signature of the constructor of {{Skeleton}} is implementation defined.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForProgrammingLanguageIdioms@1]
                version = 1
            }

            /* broken_link_c/issue/17432457 */
            ScoreReq.CompReq SkeletonDestructor {
                description = '''The {{Skeleton}} shall contain a public destructor.

                {{{virtual Skeleton::Skeleton() noexcept; }}}

                Behaviour: If the service provided by the skeleton is currently being offered at the time of the destruction, the offering shall be stopped.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceInstance@1, Communication.SupportForProgrammingLanguageIdioms@1]
                version = 1
            }

            /* broken_link_c/issue/18447605 */
            ScoreReq.CompReq SkeletonExceptionLessCreationWithInstanceId {
                description = '''The {{Skeleton}} class shall provide a non-throwing constructor using the Named Constructor idiom (See Creation of an object using Named Constructor approach)

                {{{static bmw::Result<Skeleton> Skeleton::Create(const mw::com::InstanceIdentifier &instance\_identifier) noexcept;

                }}}

                {{Create}} call shall fail if the service instance provided by the {{Skeleton}} is not unique (i.e., a service with the same serviceInstanceId is already created).

                Arguments:

                * instance\_identifier: For more details see [InstanceIdentifier.|ISSUE:17292144]

                * mode: This is the mode of the service implementation for processing service method invocations with {{kEvent}} as its default value. See Method Call Processing Mode for details

                Return:

                * {{Create}} call shall fail if the service instance provided by the {{Skeleton}} is not unique (i.e., a service with the same serviceInstanceId is already created). With the error code {{ComErrc::kServiceInstanceAlreadyExists}}.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ErrorHandling@1]
                version = 1
            }

            /* broken_link_c/issue/17434559 */
            ScoreReq.CompReq SkeletonExceptionLessCreationWithInstanceSpecifier {
                description = '''The {{Skeleton}} class shall provide a non-throwing constructor using the Named Constructor idiom (See Creation of an object using Named Constructor approach).

                {{{static bmw::Result<Skeleton> Skeleton::Create(const mw::com::InstanceSpecifier &instance\_specifier) noexcept;}}}

                {{Create}} call shall fail if the service instance provided by the {{Skeleton}} is not unique (i.e., a service with the same serviceInstanceId is already created).

                Arguments:

                * instance\_specifier:  For more details see [InstanceSpecifier.|ISSUE:18361210]

                * mode: This is the mode of the service implementation for processing service method invocations with {{kEvent}} as its default value. See Method Call Processing Mode for details.

                Return:

                * {{Create}} call shall fail if the service instance provided by the {{Skeleton}} is not unique (i.e., a service with the same serviceInstanceId is already created). With the error code {{ComErrc::kServiceInstanceAlreadyExists}}.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ErrorHandling@1]
                version = 1
            }

            /* broken_link_c/issue/17432387 */
            ScoreReq.CompReq SkeletonCopySemantics {
                description = '''The {{Skeleton}} class shall neither be copy-constructable nor copy-assignable.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.DataLoss@1, Communication.ZeroCopy@1]
                version = 1
            }

            /* broken_link_c/issue/17432438 */
            ScoreReq.CompReq SkeletonMoveSemantics {
                description = '''The {{Skeleton}}
                class shall be move-constructible as well as being move-assignable.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForProgrammingLanguageIdioms@1, Communication.SupportForMultipleProgrammingLanguages@1]
                version = 1
            }

            /* broken_link_c/issue/17434118 */
            ScoreReq.CompReq SkeletonOfferService {
                description = '''The {{mw::com}}/{{LoLa}} shall provide an {{OfferService}} method as part of the {{Skeleton}} class to offer a service to applications.

                {{{bmw::ResultBlank Skeleton::OfferService() noexcept;}}}

                Behaviour: is described in Behaviour of OfferService.

                Return value:

                If the {{Skeleton}} contains one or more instances of a SkeletonField class, then:

                *  if {{Update()}} has not been called yet on all of the {{SkeletonField}} instances, then the error code {{ComErrc::kFieldValueIsNotValid}} shall be returned.

                *  or, if any of the {{SkeletonField}} instances are defined with {{hasSetter=true}} and no SetHandler has been registered yet, then the errorcode {{ComErrc::kSetHandlerNotSet}} shall be returned.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/17434265 */
            ScoreReq.CompReq SkeletonStopOfferService {
                description = '''The {{Skeleton}} shall provide a {{StopOfferService}} method:

                {{{void Skeleton::StopOfferService() noexcept;}}}

                Behaviour: is described in Behaviour of StopOfferService.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.ServiceDiscovery@1]
                version = 1
            }
            }

            section "Skeleton_Event" {

                /* broken_link_c/issue/21840363 */
                ScoreReq.CompReq SkeletonEventClass {
                    description = '''Event members within a Skeleton Class shall be of a {{SkeletonEvent}} class, whose properties are defined in this section.

                    The name and namespace of a {{SkeletonEvent}} class shall be defined by the {{mw::com}} implementation.

                    Note: It is up to the {{mw::com}} implementation, whether it defines/generates different/explicit classes for each {{SkeletonEvent}} or whether it uses a class template for {{SkeletonEvent}} class and uses the event data type (EventType) as a template argument.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/29235002 */
                ScoreReq.CompReq SkeletonEventClassDefinition {
                    description = '''For different event data types also different {{SkeletonEvent}}
                    {{SkeletonEvent}}

                     classes shall be defined, since the event data type influences the signature of a  class. See for example SkeletonEvent class member type EventType
                    '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/21840365 */
                ScoreReq.CompReq SkeletonEventCopySemantics {
                    description = '''The {{SkeletonEvent}}
                     class shall neither be copy-constructable nor copy-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/21840366 */
                ScoreReq.CompReq SkeletonEventClassMemberTypeEventType {
                    description = '''Each {{SkeletonEvent}} class shall have a public member type {{EventType}}, which denotes the data type of an event.

                    {{{using EventType = <data type>;}}}'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/21840368 */
                ScoreReq.CompReq SkeletonEventClassAllocate {
                    description = '''The {{SkeletonEvent}} class shall contain a public method:

                    {{{bmw::Result<bmw::mw::com::SampleAllocateePtr<EventType>> SkeletonEvent::Allocate() noexcept;}}}

                    Behaviour: is described in Behaviour of Allocate.

                    Return value: returned {{bmw::Result}} which contains

                    * on success, a {{SampleAllocateePtr}} constructed from {{EventType}} (See SampleAllocateePtr).

                    * on failure, a {{bmw::ResultBlank}}, which contains a {{bmw::result::Error}}containing the value {{ComErrc::kNotOffered}} if Skeleton OfferService has not been called or the service offering has been withdrawn with a call to Skeleton StopOfferService.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.ZeroCopy@1]
                    version = 1
                }

                /* broken_link_c/issue/21840370 */
                ScoreReq.CompReq SkeletonEventClassSend {
                    description = '''The {{SkeletonEvent}} class shall contain a public method:

                    {{{ bmw::ResultBlank SkeletonEvent::Send(const EventType &value) noexcept;}}}

                    Arguments:

                    *  value: A value of type SkeletonEvent class member type EventType which will be used according to Behaviour of Update/Send with Copy.

                    Behaviour: is described in Behaviour of Update/Send with Copy.

                    Return value: {{bmw::ResultBlank}}{{bmw::result::Error}}returned  which contains a  containing the value {{ComErrc::kNotOffered}} if Skeleton OfferService has not been called or the service offering has been withdrawn with a call to Skeleton StopOfferService.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.StatelessCommunication@1]
                    version = 1
                }

                /* broken_link_c/issue/21840371 */
                ScoreReq.CompReq SkeletonEventClassZeroCopySend {
                    description = '''The {{SkeletonEvent}} class shall contain a public method:

                    {{{bmw::ResultBlank SkeletonEvent::Send(bmw::mw::com::SampleAllocateePtr<EventType> data) noexcept;}}}

                    Arguments:

                    *  data: A SampleAllocateePtr which will be used according to Behaviour of Zero-copy Update/Send.

                    Behaviour: is described in Behaviour of Zero-copy Update/Send.

                    Return value: {{bmw::ResultBlank}}{{bmw::result::Error}}returned  which contains a  containing the value {{ComErrc::kNotOffered}} if Skeleton OfferService has not been called or the service offering has been withdrawn with a call to Skeleton StopOfferService'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ZeroCopy@1]
                    version = 1
                }
            }

            section "SkeletonField" {

                section "Functionality" {

                /* broken_link_c/issue/17431949 */
                ScoreReq.CompReq SkeletonFieldClass {
                    description = '''Field members within a Skeleton Class shall be of a {{SkeletonField}} class, whose properties are defined in this section.

                    The name and namespace of a {{SkeletonField}} class shall be defined by the {{mw::com}} implementation.

                    Note: It is up to the {{mw::com}} implementation, whether it defines/generates different/explicit classes for each {{SkeletonField}} or whether it uses a class template for {{SkeletonField}} class and uses the field data type ({{FieldType}}) as a template argument.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/29235194 */
                ScoreReq.CompReq SkeletonFieldClassDefinition {
                    description = '''For different field data types also different {{SkeletonField}}
                    {{SkeletonField}}

                     classes shall be defined, since the field data type influences the signature of a  class. See for example SkeletonField class member type FieldType.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.CommunicationInterfaces@1, Communication.ServiceInstanceNames@1]
                    version = 1
                }

                /* broken_link_c/issue/18221574 */
                ScoreReq.CompReq SkeletonFieldCopySemantics {
                    description = '''The {{SkeletonField}}
                     class shall neither be copy-constructable nor copy-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/17433130 */
                ScoreReq.CompReq SkeletonFieldType {
                    description = '''Each {{SkeletonField}} class shall have a public member type {{FieldType}}, which denotes the data type of a field.

                    {{{using FieldType = <data type>;}}}'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/17434933 */
                ScoreReq.CompReq SkeletonFieldAllocate {
                    description = '''The {{SkeletonField}} class shall contain a public method:

                    {{{bmw::Result<mw::com::SampleAllocateePtr<FieldType>> SkeletonField::Allocate() noexcept;}}}

                    Behaviour: is described in Behaviour of Allocate.

                    Return value: returned {{bmw::Result}} which contains

                    * on success, a {{SampleAllocateePtr<FieldType>}} (See SampleAllocateePtr).

                    *  on failure, a {{bmw::ResultBlank}}, which contains a {{bmw::result::Error}}containing the value {{ComErrc::kNotOffered}} if Skeleton OfferService has not been called or the service offering has been withdrawn with a call to Skeleton StopOfferService.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ServiceInstance@1, Communication.ZeroCopy@1]
                    version = 1
                }

                /* broken_link_c/issue/17434775 */
                ScoreReq.CompReq SkeletonFieldClassUpdate {
                    description = '''The {{SkeletonField}} class shall contain a public method:

                    {{{ bmw::ResultBlank SkeletonField::Update(const FieldType &value) noexcept;}}}

                    Arguments:

                    *  value: A value of type ProxyField Member type FieldType which will be used according to Behaviour of Update/Send with Copy.

                    Behaviour: is described in Behaviour of Update/Send with Copy and Behaviour of Setting Field Initial Value.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.StatelessCommunication@1]
                    version = 1
                }

                /* broken_link_c/issue/17434778 */
                ScoreReq.CompReq SkeletonFieldClassZeroCopyUpdate {
                    description = '''The {{SkeletonField}} class shall contain a public method:

                    {{{bmw::ResultBlank SkeletonField::Update(mw::com::SampleAllocateePtr<FieldType> data) noexcept;}}}

                    Arguments:

                    *  data: A SampleAllocateePtr which will be used according to Behaviour of Zero-copy Update/Send.

                    Behaviour: is described in Behaviour of Zero-copy Update/Send and Behaviour of Setting Field Initial Value'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ZeroCopy@1]
                    version = 1
                }
                }
            }
        }

        section "Typed_Proxy" {

            section "Functionality" {

            /* broken_link_c/issue/14087509 */
            ScoreReq.CompReq ProxyClass {
                description = '''A {{Proxy}} class shall be based on a specific strongly typed service interface definition.

                Such a {{Proxy}} class shall either be generated by a code generator emitting C++ code at pre-compile-time, which gets a service interface definition as input in the form of an IDL (like arxml, fidl, syml).

                Or it may be generated at compile-time based on a service interface definition in the form of a C++ type definition with the help of C++ templates, which drive the generation.

                The class name and {{namespace}} of such a {{Proxy}} is not fixed and decided in the generation step (see above).

                Such a generated {{Proxy}} class then has, depending of the service interface definition it was generated from, a number of contained:

                * proxy events (0..n)

                * proxy fields (0..n)

                * proxy service methods (0..n)

                Each of these contained elements shall be represented by a public member variable.

                The name of the member variable shall be deduced from the corresponding event/field/method name of the underlying service interface definition.

                The type of the member variables is as follows:

                * event members shall be of a type providing the interface as defined in Proxy Event.

                * field members shall be of type providing the interface as defined in Proxy Field.

                * service method members shall be of type providing the interface as defined in Proxy Service Method Functionality.

                {{Proxy}}
                Note:  is the name used for the created Proxy in subsequent requirements.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.CommunicationInterfaces@1, Communication.SupportForMultipleProgrammingLanguages@1]
                version = 1
            }

            /* broken_link_c/issue/14110934 */
            ScoreReq.CompReq ProxyConstructor {
                description = '''Construction of a {{Proxy}} instance by the user shall only be possible via the public static {{Create()}} method (See Proxy Exception-less Creation).

                Therefore the signature of the constructor of {{Proxy}} is implementation defined.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForProgrammingLanguageIdioms@1]
                version = 1
            }

            /* broken_link_c/issue/14108458 */
            ScoreReq.CompReq ProxyExceptionlessCreation {
                description = '''The {{Proxy}}

                class shall provide a non-throwing constructor using the Named Constructor idiom (See Creation of an object using Named Constructor approach)

                {{{static bmw::Result<Proxy> Proxy::Create(const Proxy::HandleType &handle) noexcept;}}}

                Arguments:

                * HandleType: The given {{handle}} parameter shall be a handle returned from one of the {{Proxy::FindService()}} API overloads. See HandleType.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ErrorHandling@1]
                version = 1
            }

            /* broken_link_c/issue/21290780 */
            ScoreReq.CompReq ProxyCopySemantics {
                description = '''The {{Proxy}}
                class shall neither be copy-constructable nor copy-assignable.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.DataLoss@1, Communication.ZeroCopy@1]
                version = 1
            }

            /* broken_link_c/issue/21290799 */
            ScoreReq.CompReq ProxyMoveSemantics {
                description = '''The {{Proxy}}
                class shall be move-constructible as well as being move-assignable.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForProgrammingLanguageIdioms@1, Communication.SupportForMultipleProgrammingLanguages@1]
                version = 1
            }

            /* broken_link_c/issue/14110930 */
            ScoreReq.CompReq ProxyFindServiceWithInstanceSpecifier {
                description = '''The {{Proxy}} class shall contain a public method:

                {{{ static bmw::Result<mw::com::ServiceHandleContainer> Proxy::FindService(mw::com::InstanceSpecifier instance\_specifier) noexcept}}}

                Arguments:

                * instance\_specifier: An instance of InstanceSpecifier Class.

                Behaviour: is described in Behaviour of FindService.

                Return values: returned bmw::Result which contains

                * on success, a HandleType for each available service instance according to Behaviour of FindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kBindingFailure}} if the lookup of all service instances corresponding to the service instance (See InstanceSpecifier Correspondence to Service Instances) by the binding returned errors.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/14110933 */
            ScoreReq.CompReq ProxyFindServiceWithInstanceIdentifier {
                description = '''The {{Proxy}}
                 class shall contain a public method:

                {{{static bmw::Result<mw::com::ServiceHandleContainer> Proxy::FindService(mw::com::InstanceIdentifier instance\_identifier) noexcept}}}

                Arguments:

                *  instance\_identifier: An instance of InstanceIdentifier Class.

                Behaviour: is described in Behaviour of FindService.

                Return values: returned bmw::Result which contains

                *  on success, a progress-cursor HandleType for each available service instance according to Behaviour of FindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kBindingFailure}} if the lookup of all service instances corresponding to the service instance (See InstanceIdentifier Correspondence to Service Instances) by the binding returned errors.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/21792392 */
            ScoreReq.CompReq ProxyStartFindServiceWithInstanceSpecifier {
                description = '''The {{Proxy}}
                 class shall contain a public method:

                {{{static bmw::Result<bmw::mw::com::FindServiceHandle> Proxy::StartFindService(bmw::mw::com::FindServiceHandler handler, bmw::mw::com::InstanceSpecifier instance\_specifier) noexcept}}}

                Arguments:

                * handler: An instance of FindServiceHandler.

                *  instance\_specifier: An instance of default-cursor InstanceSpecifier Class.

                Behaviour: is described in Behaviour of StartFindService.

                Return values: returned {{bmw::Result}} which contains

                *  on success, a FindServiceHandle for stopping the search, according to Behaviour of StartFindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kFindServiceHandlerFailure}} if the handler could not be installed.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.MultiBindingSupport@1]
                version = 1
            }

            /* broken_link_c/issue/21792393 */
            ScoreReq.CompReq ProxyStartFindServiceWithInstanceIdentifier {
                description = '''The {{Proxy}}
                 class shall contain a public method:

                {{{static bmw::Result<bmw::mw::com::FindServiceHandle> Proxy::StartFindService(bmw::mw::com::FindServiceHandler handler, bmw::mw::com::InstanceIdentifier instance\_identifier) noexcept}}}

                Arguments:

                *  handler: An instance of FindServiceHandler.

                *  instance\_identifier: An instance of InstanceIdentifier Class

                Behaviour: is described in Behaviour of StartFindService.

                Return values: returned {{bmw::Result}} which contains

                *  on success, a FindServiceHandle for stopping the search, according to Behaviour of StartFindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kFindServiceHandlerFailure}} if the handler could not be installed.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/21792394 */
            ScoreReq.CompReq ProxyStopFindService {
                description = '''The {{Proxy}} class shall contain a public method:

                {{static bmw::ResultBlank Proxy::StopFindService(bmw::mw::com::FindServiceHandle handle) noexcept}}

                Arguments:

                * {{handle}}: A handle of type FindServiceHandle identifying a previously started search.

                Behaviour: Stops the asynchronous search for available services, which has been started by either Proxy StartFindService with InstanceIdentifier or Proxy StartFindService with InstanceSpecifier. After the call has returned no further calls to the user provided FindServiceHandler takes place. Calls to {{StopFindService}} with a {{FindServiceHandle}} that was already used in a call to {{StopFindService}} which did not return an error will be silently ignored.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1, Communication.SafeCommunication@1]
                version = 1
            }

            /* broken_link_c/issue/14110935 */
            ScoreReq.CompReq ProxyGetHandle {
                description = '''The {{Proxy}} class shall contain a public method:

                {{{HandleType Proxy::GetHandle() const noexcept}}}

                Return value: the handle from which the {{Proxy}} instance has been created whose type is specified in Proxy HandleType class.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceInstance@1]
                version = 1
            }

            /* broken_link_c/issue/14110936 */
            ScoreReq.CompReq ProxyHandleTypeClass {
                description = '''The {{Proxy}} class shall contain a public member type {{HandleType}} which shall adhere to the .requirements of HandleType'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.CommunicationInterfaces@1]
                version = 1
            }
            }

            section "Proxy_Event" {

                /* broken_link_c/issue/14137268 */
                ScoreReq.CompReq ProxyEventClass {
                    description = '''Event members within a Proxy Class shall be of a {{ProxyEvent}} class, whose properties are defined in this section.

                    The name and namespace of a {{ProxyEvent}} shall be defined by the {{mw::com}} implementation.

                    Note: It is up to the {{mw::com}} implementation, whether it defines/generates different/explicit classes for each {{ProxyEvent}} or whether it uses a class template for {{ProxyEvent}} and uses the event data type ({{SampleType}}) as a template argument.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/29235350 */
                ScoreReq.CompReq ProxyEventClassDefinition {
                    description = '''For different event data types also different {{ProxyEvent}}
                    {{ProxyEvent}}

                     classes shall be defined, since the event data type influences the signature of a  class. See for example ProxyEvent Member type SampleType
                    '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/14137294 */
                ScoreReq.CompReq ProxyEventMemberTypeSampleType {
                    description = '''The {{ProxyEvent}} class shall have a public member type {{SampleType}}, which denotes the data type of an event.

                    {{{using SampleType = <data type of event>}}}'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14137269 */
                ScoreReq.CompReq ProxyEventCopySemantics {
                    description = '''The ï»¿{{ProxyEvent}} class shall neither be copy-constructable nor copy-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/14137270 */
                ScoreReq.CompReq ProxyEventSubscribe {
                    description = '''The {{ProxyEvent}} class shall provide a public method:

                    {{{bmw::ResultBlank ProxyEvent::Subscribe(std::size\_t max\_sample\_count) noexcept}}}

                    Behaviour is described in default-cursor Behaviour of Subscribe.

                    Return value is described in default-cursor Return value of Subscribe.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14137271 */
                ScoreReq.CompReq ProxyEventUnsubscribe {
                    description = '''The {{ProxyEvent}} class shall provide a public method:

                    {{{void ProxyEvent::Unsubscribe() noexcept; }}}

                    Behaviour is described in Behaviour of Unsubscribe.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14137272 */
                ScoreReq.CompReq ProxyEventGetSubscriptionState {
                    description = '''The {{ProxyClass}} shall provide a public method:

                    {{{SubscriptionState ProxyEvent::GetSubscriptionState() const noexcept}}}

                    Return value: returns the subscription state of an event.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/18805456 */
                ScoreReq.CompReq ProxyEventSetSubscriptionStateChangeHandler {
                    description = '''The {{ProxyEvent}} class shall provide a public method:

                    {{{bmw::ResultBlank ProxyEvent::SetSubscriptionStateChangeHandler(SubscriptionStateChangeHandler subscription\_state\_change\_handler) noexcept; }}}

                    Arguments:

                    * subscription\_state\_change\_handler: See SubscriptionStateChangeHandler for its definition.

                    Behaviour: is described in Behaviour of SetSubscriptionStateChangeHandler.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.EventType@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/18805552 */
                ScoreReq.CompReq ProxyEventUnsetSubscriptionStateChangeHandler {
                    description = '''The {{ProxyEvent}} class shall provide a public method:

                    {{{void ProxyEvent::UnsetSubscriptionStateChangeHandler() noexcept;}}}

                    Behaviour: is described in Behaviour of UnsetSubscriptionStateChangeHandler.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.EventType@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/14137273 */
                ScoreReq.CompReq ProxyEventGetNewSamples {
                    description = '''The {{ProxyEvent}}
                    shall provide a public method:

                    {{{template <typename F>
                    bmw::Result<std::size\_t> ProxyEvent::GetNewSamples(F&& receiver, std::size\_t max\_num\_samples) noexcept;}}}

                    Arguments:

                    *  receiver: Callable that fulfills the signature requirement in GetNewSamples receiver signature.

                    *  max\_num\_samples: size\_t value whose behaviour is defined in Behaviour of GetNewSamples

                    Behaviour is described in Behaviour of GetNewSamples

                    Return value:{{bmw::Result}} returned  which contains

                    *  on success, a value defined in Return value of successful GetNewSamples.

                    *  or, a {{bmw::result::Error}} containing the value {{kMaxSamplesReached}} when the implementation has a new sample, but can't call the receiver callback, because the number of {{SamplePtr}} s currently held by the application has met the maximum number passed to the ProxyEvent Subscribe call.

                    *  {{bmw::result::Error}}, according to or, a Error Codes relating to Active Subscription.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1, Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14137274 */
                ScoreReq.CompReq ProxyEventSetReceiveHandler {
                    description = '''The {{ProxyEvent}}
                     shall provide a public method:

                    {{{bmw::ResultBlank ProxyEvent::SetReceiveHandler(mw::com::EventReceiveHandler handler) noexcept;}}}

                    Arguments:

                    *  handler See default-cursor Event Receive Handler for its definition.

                    Behaviour is described in Behaviour of SetReceiveHandler.

                    Return value: In case {{SetReceiveHandler()}} fails, {{ComErrc::kSetHandlerNotSet}} shall be returned in the {{Result}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.Method@1]
                    version = 1
                }

                /* broken_link_c/issue/14137275 */
                ScoreReq.CompReq ProxyEventUnsetReceiveHandler {
                    description = '''The {{ProxyEvent}}
                     shall provide a public method:

                    {{{bmw::ResultBlank ProxyEvent::UnsetReceiveHandler() noexcept}}}

                    Behaviour is described in Behaviour of UnsetReceiveHandler.

                    Return value: {{UnsetReceiveHandler()}}{{ComErrc::kUnsetFailure}}{{Result}}In case  fails,  shall be returned in the '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.Method@1]
                    version = 1
                }

                /* broken_link_c/issue/14137276 */
                ScoreReq.CompReq ProxyEventGetFreeSampleCount {
                    description = '''The {{ProxyEvent}}
                    shall provide a public method:

                    {{{std::size\_t ProxyEvent::GetFreeSampleCount() const noexcept}}}

                    Return value is described in Return value of GetFreeSampleCount.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1, Communication.DataReordering@1]
                    version = 1
                }

                /* broken_link_c/issue/14137277 */
                ScoreReq.CompReq ProxyEventGetNumNewSamplesAvailable {
                    description = '''The {{ProxyEvent}}
                    shall provide a public method:

                    {{{bmw::Result<std::size\_t> ProxyEvent::GetNumNewSamplesAvailable() const noexcept}}}

                    Behaviour is described in progress-cursor Behaviour of GetNumNewSamplesAvailable.

                    Return value:{{bmw::Result}} returned  which contains

                    *  on success, number of new samples available as described in Behaviour of GetNumNewSamplesAvailable,

                    *  or, a {{bmw::result::ErrorCode}}, according to Error Codes relating to Active Subscription.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1]
                    version = 1
                }
            }

            section "Proxy_Field" {

                /* broken_link_c/issue/17291542 */
                ScoreReq.CompReq ProxyFieldClass {
                    description = '''Field members within a Proxy Class shall be of a {{ProxyField}} class, whose properties are defined in this section.

                    The name and namespace of a {{ProxyField}} shall be defined by the {{mw::com}} implementation.

                    Note: It is up to the {{mw::com}} implementation, whether it defines/generates different/explicit classes for each {{ProxyField}} or whether it uses a class template for {{ProxyField}} and uses the field data type ({{FieldType}}) as a template argument.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/29235459 */
                ScoreReq.CompReq ProxyFieldClassDefinition {
                    description = '''For different field data types also different {{ProxyField}}
                    {{ProxyField}}

                     classes shall be defined, since the field data type influences the signature of a  class. See for example the ProxyField Member type FieldType
                    '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.CommunicationInterfaces@1, Communication.ServiceInstanceNames@1]
                    version = 1
                }

                /* broken_link_c/issue/17291997 */
                ScoreReq.CompReq ProxyFieldMemberTypeFieldType {
                    description = '''The {{ProxyField}} class shall have a public member type {{FieldType}}, which denotes the data type of a field.

                    {{{using FieldType = <data type of field>}}}'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/17397027 */
                ScoreReq.CompReq ProxyFieldCopySemantics {
                    description = '''The {{ProxyField}}
                     class shall neither be copy-constructable nor copy-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/17292398 */
                ScoreReq.CompReq ProxyFieldSubscribe {
                    description = '''The {{ProxyField}} class shall provide a public method:

                    {{{ bmw::ResultBlank ProxyField::Subscribe(std::size\_t max\_sample\_count) noexcept; }}}

                    Behaviour is described in Behaviour of Subscribe.

                    Return value is described in Return value of Subscribe.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/17292399 */
                ScoreReq.CompReq ProxyFieldUnsubscribe {
                    description = '''A {{ProxyField}} class shall provide a public method:

                    {{{void ProxyField::Unsubscribe() noexcept; }}}

                    Behaviour is described in Behaviour of Unsubscribe'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SafeCommunication@1]
                    version = 1
                }

                /* broken_link_c/issue/17292400 */
                ScoreReq.CompReq ProxyFieldGetSubscriptionState {
                    description = '''The {{ProxyField}} shall provide a public method:

                    {{{SubscriptionState ProxyField::GetSubscriptionState() const noexcept; }}}

                    Return value: returns the subscription state of an event.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/18860207 */
                ScoreReq.CompReq ProxyFieldSetSubscriptionStateChangeHandler {
                    description = '''The {{ProxyField}}
                     class shall provide a public method:

                    {{{bmw::ResultBlank ProxyField::SetSubscriptionStateChangeHandler(SubscriptionStateChangeHandler subscription\_state\_change\_handler) noexcept; }}}

                    Arguments:

                    *  subscription\_state\_change\_handler: See progress-cursor SubscriptionStateChangeHandler for its definition.

                    Behaviour: is described in default-cursor Behaviour of SetSubscriptionStateChangeHandler.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1]
                    version = 1
                }

                /* broken_link_c/issue/18876709 */
                ScoreReq.CompReq ProxyFieldUnsetSubscriptionStateChangeHandler {
                    description = '''The {{ProxyField}}
                     class shall provide a public method:

                    {{{void ProxyField::UnsetSubscriptionStateChangeHandler() noexcept;}}}

                    Behaviour: is described in Behaviour of UnsetSubscriptionStateChangeHandler.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.Method@1]
                    version = 1
                }

                /* broken_link_c/issue/17292401 */
                ScoreReq.CompReq ProxyFieldGetNewSamples {
                    description = '''The {{ProxyField}}
                    shall provide a public method:

                    {{{template <typename F>
                    bmw::Result<std::size\_t> ProxyField::GetNewSamples(F&& receiver, std::size\_t max\_num\_samples) noexcept;}}}

                    Arguments:

                    *  receiver: Callable that fulfills the signature requirement in progress-cursor GetNewSamples receiver signature.

                    *  max\_num\_samples: size\_t value whose behaviour is defined in Behaviour of GetNewSamples

                    Behaviour is described in Behaviour of GetNewSamples

                    Return value:{{bmw::Result}} returned  which contains

                    *  on success, a value defined in Return value of successful GetNewSamples.

                    *  or, a {{bmw::result::Error}} containing the value {{kMaxSamplesReached}} when the implementation has a new sample, but can't call the receiver callback, because the number of {{SamplePtr}} s currently held by the application has met the maximum number passed to the ProxyField Subscribe call.

                    *  {{bmw::result::Error}}, according to or, a Error Codes relating to Active Subscription.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/17292404 */
                ScoreReq.CompReq ProxyFieldSetReceiveHandler {
                    description = '''The {{ProxyField}}
                     shall provide a public method:

                    {{{bmw::ResultBlank ProxyField::SetReceiveHandler(mw::com::EventReceiveHandler handler) noexcept;}}}

                    Arguments:

                    *  handler See default-cursor Event Receive Handler for its definition.

                    Behaviour is described in default-cursor Behaviour of SetReceiveHandler.

                    Return value: In case {{SetReceiveHandler()}} fails, {{ComErrc::kSetHandlerNotSet}} shall be returned in the {{Result}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.Method@1]
                    version = 1
                }

                /* broken_link_c/issue/17292405 */
                ScoreReq.CompReq ProxyFieldUnsetReceiveHandler {
                    description = '''The {{ProxyField}}
                     shall provide a public method:

                    {{{bmw::ResultBlank ProxyField::UnsetReceiveHandler() noexcept}}}

                    Behaviour is described in progress-cursor Behaviour of UnsetReceiveHandler.

                    Return value: {{UnsetReceiveHandler()}}{{ComErrc::kUnsetFailure}}{{Result}}In case  fails,  shall be returned in the '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.Method@1]
                    version = 1
                }

                /* broken_link_c/issue/17292402 */
                ScoreReq.CompReq ProxyFieldGetFreeSampleCount {
                    description = '''The {{ProxyField}}
                    shall provide a public method:

                    {{{std::size\_t ProxyField::GetFreeSampleCount() const noexcept}}}

                    Return value is described in Return value of GetFreeSampleCount.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SafeCommunication@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/17292403 */
                ScoreReq.CompReq ProxyFieldGetNumNewSamplesAvailable {
                    description = '''The {{ProxyField}}
                    shall provide a public method:

                    {{{bmw::Result<std::size\_t> ProxyField::GetNumNewSamplesAvailable() const noexcept}}}

                    Behaviour is described in progress-cursor Behaviour of GetNumNewSamplesAvailable.

                    Return value:{{bmw::Result}} returned  which contains

                    *  on success, number of new samples available as described in Behaviour of GetNumNewSamplesAvailable,

                    *  or, a {{bmw::result::ErrorCode}}, according to Error Codes relating to Active Subscription.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataReordering@1]
                    version = 1
                }
            }
        }

        section "Generic_Proxy" {

            section "Functionality" {

                /* broken_link_c/issue/15600146 */
                ScoreReq.CompReq EventListSource {
                    description = '''A {{GenericProxy}} instance shall deduce its supported events from the {{LoLa}} json configuration containing deployment information.

                    Note: A {{GenericProxy}} is created via the Create API based on {{HandleType}} containing its related deployment information.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/15601194 */
                ScoreReq.CompReq EventTypeInfoSource {
                    description = '''The type information for each of the events supported by a {{GenericProxy}} instance, shall be gathered from the shared memory data section published by the {{LoLa}} skeleton instance providing the service instance, the {{GenericProxy}} is connected with.

                    Note: This information is needed for the [GetSampleSize() API|ISSUE:14035184].'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/15603826 */
                ScoreReq.CompReq ReactionOnMissingEventTypeInfo {
                    description = '''In case, that there is no related Event Type Info source provided in shared memory for a given Event enlisted in the deployment for the {{GenericProxy}}, an ERROR message shall be logged.

                    No corresponding Event shall be inserted into the event map member of the {{GenericProxy}} instance.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

            /* broken_link_c/issue/14005667 */
            ScoreReq.CompReq GenericProxyClass {
                description = '''The class {{GenericProxy}} is not a generated class and shall be provided in the namespace {{bmw::mw::com}}. {{GenericProxy}}{{platform/aas/mw/com/types.h}}Users shall be able to access the definition of  by inclusion of '''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.CommunicationInterfaces@1, Communication.SupportForMultipleProgrammingLanguages@1]
                version = 1
            }

            /* broken_link_c/issue/14005999 */
            ScoreReq.CompReq GenericProxyConstructor {
                description = '''The constructor of the class {{GenericProxy}} shall be private.

                Note: Construction of a {{GenericProxy}} instance by the user shall only be possible via the public static {{Create()}} method (See GenericProxy Exception-less Creation).

                Therefore the signature of the constructor of {{GenericProxy}} is implementation defined.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForProgrammingLanguageIdioms@1]
                version = 1
            }

            /* broken_link_c/issue/14005969 */
            ScoreReq.CompReq GenericProxyExceptionLessCreation {
                description = '''The {{GenericProxy}} class shall provide a non-throwing constructor using the Named Constructor idom (See Creation of an object using Named Constructor approach.

                {{{static bmw::Result<GenericProxy> GenericProxy::Create(const GenericProxy::HandleType &handle) noexcept;}}}

                Arguments:

                * HandleType: The given {{handle}} parameter shall be a handle returned from one of the {{GenericProxy::FindService()}} API overloads.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ErrorHandling@1]
                version = 1
            }

            /* broken_link_c/issue/17292012 */
            ScoreReq.CompReq GenericProxyCopySemantics {
                description = '''The {{GenericProxy}} class shall neither be copy-constructable nor copy-assignable.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.DataLoss@1, Communication.ZeroCopy@1]
                version = 1
            }

            /* broken_link_c/issue/17292032 */
            ScoreReq.CompReq GenericProxyMoveSemantics {
                description = '''The {{GenericProxy}} class shall be move-constructible as well as being move-assignable.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForProgrammingLanguageIdioms@1, Communication.SupportForMultipleProgrammingLanguages@1]
                version = 1
            }

            /* broken_link_c/issue/14005977 */
            ScoreReq.CompReq GenericProxyFindServiceWithInstanceSpecifier {
                description = '''The {{GenericProxy}}
                 class shall contain a public method:

                {{{static bmw::Result<mw::com::ServiceHandleContainer> GenericProxy::FindService(mw::com::InstanceSpecifier instance\_specifier) noexcept}}}

                Arguments:

                *  instance\_specifier: An instance of default-cursor InstanceSpecifier Class.

                Behaviour: is described in default-cursor Behaviour of FindService.

                Return values: returned bmw::Result which contains

                *  on success, a HandleType for each available service instance according to Behaviour of FindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kBindingFailure}} if the lookup of all service instances corresponding to the service instance (See InstanceSpecifier Correspondence to Service Instances) by the binding returned errors.

                *  '''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/14005991 */
            ScoreReq.CompReq GenericProxyFindServiceWithInstanceIdentifier {
                description = '''The {{GenericProxy}}

                 class shall contain a public method:

                {{{static bmw::Result<mw::com::ServiceHandleContainer> GenericProxy::FindService(mw::com::InstanceIdentifier instance\_identifier) noexcept}}}

                Arguments:

                *  instance\_identifier: An instance of InstanceIdentifier Class.

                Behaviour: is described in Behaviour of FindService.

                Return values: returned bmw::Result which contains

                *  on success, a HandleType for each available service instance according to Behaviour of FindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kBindingFailure}} if the lookup of all service instances corresponding to the service instance (See InstanceSpecifier Correspondence to Service Instances) by the binding returned errors.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/21788695 */
            ScoreReq.CompReq GenericProxyStartFindServiceWithInstanceSpecifier {
                description = '''The {{GenericProxy}}
                 class shall contain a public method:

                {{{static bmw::Result<mw::com::FindServiceHandle> GenericProxy::StartFindService(bmw::mw::com::FindServiceHandler handler, bmw::mw::com::InstanceSpecifier instance\_specifier) noexcept}}}

                Arguments:

                * handler: An instance of FindServiceHandler.

                *  instance\_specifier: An instance of default-cursor InstanceSpecifier Class.

                Behaviour: is described in Behaviour of StartFindService.

                Return values: returned {{bmw::Result}} which contains

                *  on success, a FindServiceHandle for stopping the search, according to Behaviour of StartFindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kFindServiceHandlerFailure}} if the handler could not be installed.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.MultiBindingSupport@1]
                version = 1
            }

            /* broken_link_c/issue/21790264 */
            ScoreReq.CompReq GenericProxyStartFindServiceWithInstanceIdentifier {
                description = '''The {{GenericProxy}}
                 class shall contain a public method:

                {{{static bmw::Result<bmw::mw::com::FindServiceHandle> GenericProxy::StartFindService(bmw::mw::com::FindServiceHandler handler, bmw::mw::com::InstanceIdentifier instance\_identifier) noexcept}}}

                Arguments:

                *  handler: An instance of FindServiceHandler.

                *  instance\_identifier: An instance of InstanceIdentifier Class

                Behaviour: is described in Behaviour of StartFindService.

                Return values: returned {{bmw::Result}} which contains

                *  on success, a FindServiceHandle for stopping the search, according to Behaviour of StartFindService.

                *  or, a {{bmw::result::Error}} containing the value {{ComErrc::kFindServiceHandlerFailure}} if the handler could not be installed.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/21790756 */
            ScoreReq.CompReq GenericProxyStopFindService {
                description = '''The {{GenericProxy}} class shall contain a public method:

                {{static bmw::ResultBlank GenericProxy::StopFindService(mw::com::FindServiceHandle handle) noexcept}}

                Arguments:

                * {{handle}}: A handle of type FindServiceHandle identifying a previously started search.

                Behaviour: Stops the asynchronous search for available services, which has been started by either GenericProxy StartFindService with InstanceIdentifier or GenericProxy StartFindService with InstanceSpecifier. After the call has returned no further calls to the user provided FindServiceHandler takes place.

                Return values: returned {{bmw::ResultBlank}}, which contains a {{bmw::result::Error}} containing the value {{ComErrc::kInvalidHandle}}, in case the given handle hasn't been returned by a corresponding {{StartFindService}} call on the same class or is a handle for a search, which has already been stopped.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1, Communication.SafeCommunication@1]
                version = 1
            }

            /* broken_link_c/issue/14006006 */
            ScoreReq.CompReq GenericProxyGetEvents {
                description = '''The {{GenericProxy}} class shall contain a {{public}} method:

                {{{GenericProxy::EventMap& GenericProxy::GetEvents() noexcept }}}

                Return value: the map of events the {{GenericProxy}} provides (See GenericProxy EventMap class).'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.EventType@1]
                version = 1
            }

            /* broken_link_c/issue/14030261 */
            ScoreReq.CompReq GenericProxyGetHandle {
                description = '''The {{GenericProxy}} class shall contain a public method:

                {{{HandleType GenericProxy::GetHandle() const noexcept}}}

                Return value: the {{GenericProxy}}handle from which the  instance has been created whose type is specified in GenericProxy HandleType class.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceInstance@1]
                version = 1
            }

            /* broken_link_c/issue/14030385 */
            ScoreReq.CompReq GenericProxyHandleTypeClass {
                description = '''The {{GenericProxy}}
                {{HandleType}}

                 class shall contain a public member type  which shall adhere to the requirements of HandleType'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.CommunicationInterfaces@1]
                version = 1
            }

            /* broken_link_c/issue/14031112 */
            ScoreReq.CompReq GenericProxyEventMapClass {
                description = '''{{GenericProxy}} class shall have a {{public}} nested class EventMap. The {{GenericProxyEvent}}s that shall be contained in {{EventMap}} are according to Event List Source.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.EventType@1]
                version = 1
            }

            /* broken_link_c/issue/14031544 */
            ScoreReq.CompReq GenericProxyEventMapClassProperties {
                description = '''{{GenericProxy::EventMap}} shall provide a mapping between event names in the form of {{amp::string\_view}} and {{GenericProxyEvent}}.

                It shall provide at least the following signature, which is taken from {{std::map}} and shall behave identically to {{std::map<amp::string\_view, GenericProxyEvent>}} with regards to the listed signatures:

                * cbegin()

                * cend()

                * find()

                * size()

                * empty()'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.EventType@1]
                version = 1
            }
            }

            section "Generic_Proxy_Event" {

                /* broken_link_c/issue/14031999 */
                ScoreReq.CompReq GenericProxyEventClass {
                    description = '''Event members within a GenericProxy Class shall be of a {{GenericProxyEvent}} class, whose properties are defined in this section.

                    {{GenericProxyEvent}}

                    {{bmw::mw::com}}
                    The  shall be provided in the namespace

                    The class {{GenericProxyEvent}} is essentially a ProxyEvent class class, where the concrete event data type / {{SampleType}} is unknown and therefore represented as {{void}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1, Communication.CommunicationInterfaces@1]
                    version = 1
                }

                /* broken_link_c/issue/20237033 */
                ScoreReq.CompReq GenericProxyEventDestructor {
                    description = '''The {{destructor}} of {{GenericProxyEvent}} shall fulfill requirement Implicit Lifetime ending by destruction of context with regard to callables registered by the following APIs:

                    * {{SetReceiveHandler}} (See GenericProxyEvent SetReceiveHandler)'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForProgrammingLanguageIdioms@1]
                    version = 1
                }

                /* broken_link_c/issue/14032718 */
                ScoreReq.CompReq GenericProxyEventCopySemantics {
                    description = '''The {{GenericProxyEvent}}
                     class shall neither be copy-constructable nor copy-assignable'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1, Communication.ZeroCopy@1]
                    version = 1
                }

                /* broken_link_c/issue/14033248 */
                ScoreReq.CompReq GenericProxyEventSubscribe {
                    description = '''A {{GenericProxyEvent}}
                     class shall provide a public method:

                    {{{bmw::ResultBlank GenericProxyEvent::Subscribe(std::size\_t max\_sample\_count) noexcept}}}

                    Behaviour is described in Behaviour of Subscribe.

                    Return value is described in Return value of Subscribe.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14033377 */
                ScoreReq.CompReq GenericProxyEventUnsubscribe {
                    description = '''Class {{GenericProxyEvent}} shall provide a public method:

                    {{{void GenericProxyEvent::Unsubscribe() noexcept}}}

                    Behaviour is described in Behaviour of Unsubscribe.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14034825 */
                ScoreReq.CompReq GenericProxyEventGetSubscriptionState {
                    description = '''A {{GenericProxyEvent}} shall provide a public method:

                    {{{SubscriptionState GenericProxyEvent::GetSubscriptionState() const noexcept; }}}

                    Return value: returns the subscription state of an event.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/21466689 */
                ScoreReq.CompReq GenericProxyEventSetSubscriptionStateChangeHandler {
                    description = '''The {{GenericProxyEvent}}

                     class shall provide a public method:

                    {{{bmw::ResultBlank GenericProxyEvent::SetSubscriptionStateChangeHandler(SubscriptionStateChangeHandler subscription\_state\_change\_handler) noexcept; }}}

                    Arguments:

                    *  subscription\_state\_change\_handler: See SubscriptionStateChangeHandler for its definition.

                    Behaviour: is described in Behaviour of SetSubscriptionStateChangeHandler.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.EventType@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/21466698 */
                ScoreReq.CompReq GenericProxyEventUnsetSubscriptionStateChangeHandler {
                    description = '''The {{GenericProxyEvent}}
                     class shall provide a public method:

                    {{{void GenericProxyEvent::UnsetSubscriptionStateChangeHandler() noexcept;}}}

                    Behaviour: is described in default-cursor Behaviour of UnsetSubscriptionStateChangeHandler.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.EventType@1, Communication.ProducerConsumerPattern@1]
                    version = 1
                }

                /* broken_link_c/issue/14034910 */
                ScoreReq.CompReq GenericProxyEventGetNewSamples {
                    description = '''The {{GenericProxyEvent}} shall provide a public method:

                    {{{template <typename F>
                    bmw::Result<std::size\_t> GenericProxyEvent::GetNewSamples(F&& receiver, std::size\_t max\_num\_samples) noexcept;}}}

                    Arguments:

                    * receiver: Callable that fulfills the signature requirement in GetNewSamples receiver signature.

                    * max\_num\_samples: size\_t value whose behaviour is defined in Behaviour of GetNewSamples

                    Behaviour is described in Behaviour of GetNewSamples

                    Return value:{{bmw::Result}} returned  which contains

                    * on success, a value defined in Return value of successful GetNewSamples.

                    *  or, a {{bmw::result::Error}} containing the value {{kMaxSamplesReached}} when the implementation has a new sample, but can't call the receiver callback, because the number of {{SamplePtr}} s currently held by the application has met the maximum number passed to the GenericProxyEvent Subscribe call.

                    * or, a {{bmw::result::Error}}, according to Error Codes relating to Active Subscription.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1, Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14034916 */
                ScoreReq.CompReq GenericProxyEventSetReceiveHandler {
                    description = '''The {{GenericProxyEvent}} shall provide a public method:

                    {{{bmw::ResultBlank GenericProxyEvent::SetReceiveHandler(mw::com::EventReceiveHandler handler) noexcept;}}}

                    Arguments:

                    *  EventReceiveHandler: See Event Receive Handler for its definition.

                    Behaviour is described in Behaviour of SetReceiveHandler.

                    Return value: In case {{SetReceiveHandler()}} fails, {{ComErrc::kSetHandlerNotSet}} shall be returned in the {{Result}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.Method@1]
                    version = 1
                }

                /* broken_link_c/issue/14035152 */
                ScoreReq.CompReq GenericProxyEventUnsetReceiveHandler {
                    description = '''The {{GenericProxyEvent}} shall provide a public method:

                    {{{bmw::ResultBlank GenericProxyEvent::UnsetReceiveHandler() noexcept}}}

                    Behaviour is described in Behaviour of UnsetReceiveHandler.

                    Return value: {{UnsetReceiveHandler()}}{{ComErrc::kUnsetFailure}}{{Result}}In case  fails,  shall be returned in the '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.Method@1]
                    version = 1
                }

                /* broken_link_c/issue/14035121 */
                ScoreReq.CompReq GenericProxyEventGetFreeSampleCount {
                    description = '''The {{GenericProxyEvent}} shall provide a public method:

                    {{{std::size\_t GenericProxyEvent::GetFreeSampleCount() const noexcept}}}

                    Return value is described in Return value of GetFreeSampleCount.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1, Communication.DataReordering@1]
                    version = 1
                }

                /* broken_link_c/issue/14035142 */
                ScoreReq.CompReq GenericProxyEventGetNumNewSamplesAvailable {
                    description = '''The {{GenericProxyEvent}} shall provide a public method:

                    {{{bmw::Result<std::size\_t> GenericProxyEvent::GetNumNewSamplesAvailable() const noexcept}}}

                    Behaviour is described in Behaviour of GetNumNewSamplesAvailable.

                    Return value: returned {{bmw::Result}} which contains

                    * on success, number of new samples available as described in Behaviour of GetNumNewSamplesAvailable,

                    * or, a {{bmw::result::ErrorCode}}, according to Error Codes relating to Active Subscription'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/14035184 */
                ScoreReq.CompReq GenericProxyEventGetSampleSize {
                    description = '''The {{GenericProxyEvent}} shall provide a public method:

                    {{{std::size\_t GenericProxyEvent::GetSampleSize() const noexcept}}}

                    Behaviour: {{GetSampleSize}} shall adhere to the re-entrancy and thread-safety specifications described in Re-entrancy and Thread-safety.

                    Return value: returns the aligned size in bytes of the underlying event sample data type. I.e. in case the underlying data type is T, it shall return {{sizeof(T)}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/14035199 */
                ScoreReq.CompReq GenericProxyEventHasSerializedFormat {
                    description = '''The {{GenericProxyEvent}} shall provide a public method:

                    {{{bool GenericProxyEvent::HasSerializedFormat() const noexcept}}}

                    Behaviour: {{HasSerializedFormat}} shall adhere to the re-entrancy and thread-safety specifications described in Re-entrancy and Thread-safety. {{mw::com}}{{false}}Our  implementation shall always return  in case the shared-memory based binding is used.

                    Return value: {{GenericProxyEvent}}{{true}}{{false}}returns whether the representation of a sample event provided by the  instance has some (internal) serialization format ( or is 1:1 the binary representation of the underlying C++ data type of the event sample ('''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.EventType@1]
                    version = 1
                }
            }
        }

        section "Common_API_Types" {

            /* broken_link_c/issue/21778053 */
            ScoreReq.CompReq TypesHeaderFile {
                description = '''All common API types provided by {{mw::com}} and used within PUBLIC interfaces of {{mw::com}} shall be accessible via inclusion of {{/mw/com/types.h}}

                All common API types are enlisted under Common API Types.

                Note: Generated types (e.g. types depending on the individual service interface definition described by an IDL) are excluded here!'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                version = 1
            }

            /* broken_link_c/issue/14034769 */
            ScoreReq.CompReq SubscriptionState {
                description = '''The SubscriptionState for an {{Event}} or {{Field}} shall be located  in namespace {{mw::com}} and shall have the following definition:

                {{{enum class SubscriptionState : std::uint8\_t {
                  kSubscribed,
                  kNotSubscribed,
                  kSubscriptionPending
                };}}}

                The SubscriptionState expresses the state of a event or field subscription on the consumer/proxy side. The semantics of the enum values shall be:

                * {{kSubscribed}}: Subscription has been successfully acknowledged by the provider side and has not been withdrawn by the provider (implicitly by stop-offer of the enclosing service or a negative acknowlege/refusal of the subscribe)

                * {{kNotSubscribed}}:In case of the following cases:

                  * Subscribe() has not been called or the last Subscribe() has been withdrawn with call to Unsubscribe()

                  * Last call to Subscribe() has been rejected/negatively acknowledged by the provider side or provider side explicitly cancels an already acknowldged subscription.

                * {{kSubscriptionPending}}:

                  * Subscription() call is:

                  ** in the state to being dispatched to the provider side

                  ** has been already dispatched to the provider side, but acknowlegde from provider side is pending

                  * state was already in {{kSubscribed}}, but then the whole enclosing providing service instance has been stopped offering. This is the "auto-reconnect mode". As soon as the service instance is detected being offered again, the Subscribe() will get automatically dispatched to the provider again.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ProducerConsumerPattern@1]
                version = 1
            }

            /* broken_link_c/issue/14035954 */
            ScoreReq.CompReq EventReceiveHandler {
                description = '''{{mw::com}} shall provide the definition of {{EventReceiveHandler}} in namespace {{bmw::mw::com}} as a function wrapper without parameters for the handler function that gets called by the {{mw::com}} implementation in case new event data arrives for an event. The event receiver must provide the function implementation which is not required to be re-entrant.

                I.e. the {{mw::com}} implementation assures call serialization to an {{EventReceiveHandler}} instance for a given event instance.

                The signature of an EventReceiveHandler is:

                {{{void(void)}}}

                {{GetNewSamples}}

                The {{EventReceiveHandler}} constitutes a function without parameters and has to use the  method of the specific class instance to which it's passed to access the retrieved event data.

                The type chosen for {{EventReceiveHandler}} by the {{mw::com}} provider shall allow construction from any callable, with the given signature.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.EventType@1]
                version = 1
            }

            /* broken_link_c/issue/18805500 */
            ScoreReq.CompReq SubscriptionStateChangeHandler {
                description = '''{{mw::com}} shall provide the definition of {{SubscriptionStateChangeHandler}} in namespace {{mw::com}} as a function wrapper for the handler function that gets called by the {{mw::com}} implementation in case the {{SubscriptionState}} (see SubscriptionState) of an event has changed. The event receiver must provide the function implementation which is not required to be re-entrant for the same event instance.

                I.e. the {{mw::com}} implementation assures call serialization to an {{SubscriptionStateChangeHandler}} instance for a given event instance.

                The signature of an SubscriptionStateChangeHandler is:

                {{{void(SubscriptionState)}}}

                The type chosen for {{SubscriptionStateChangeHandler}} by the {{mw::com}} provider shall allow construction from any callable, with the given signature.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.EventType@1]
                version = 1
            }

            /* broken_link_c/issue/14116410 */
            ScoreReq.CompReq HandleType {
                description = '''{{mw::com}} implementation shall provide the definition of {{HandleType}}. It types the handle for a specific service instance and shall contain the information that is needed to create a ServiceProxy (either a TypedProxy or a GenericProxy)

                The definition of the {{HandleType}} can be extended by the {{mw::com}} implementation provider, but at least the given class and class method signatures must be preserved.

                {{HandleType}} shall satisfy the EqualityComparable requirements according to table 17 and the LessThanComparable requirements according to table 18 of section 17.6.3.1 of [ISO/IEC 14882:2011]. These requirements are fulfilled if the following operators are provided: operator== and operator<.

                {{HandleType}} shall allow:

                * copy construction and assignment

                * move construction and assignment

                so that it allows storing and managing {{HandleType}}s in C++ container classes by the using application.

                The definition of the {{HandleType}} class shall be located inside the ServiceProxy class defined by {{TypedProxy}} or a {{GenericProxy}}. This allows the {{mw::com}} implementation to provide handles with different implementation dependent on the binding of the represented service.

                {{{class HandleType {
                 public:
                 bool operator==(const HandleType& other) const;
                 bool operator<(const HandleType& other) const;
                 const ara::com::InstanceIdentifier& GetInstanceId() const;
                }
                }}}

                Since the {{mw::com/LoLa}} is responsible for creation of handles and the application just uses instances of it, the constructor signature is not part of the {{HandleType}} specification, but the constructor shall not be public.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                version = 1
            }

            /* broken_link_c/issue/21792716 */
            ScoreReq.CompReq ServiceHandleContainer {
                description = '''{{mw::com}} shall provide a class {{ServiceHandleContainer}} in namespace {{bmw::mw::com}}, which acts as a container for instances of HandleType Class

                {{ServiceHandleContainer}} must adhere to the following  C++ named requirements: `SequenceContainer <https://en.cppreference.com/w/cpp/named\_req/SequenceContainer>`\_
                A std::vector for example fulfills these requirements.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/21470910 */
            ScoreReq.CompReq SamplePtr {
                description = '''{{mw::com}}''SamplePtr''object. shall provide a  template which provides a pointer to a managed data

                The implementation shall at least contain the following interface:

                {{{template< typename T >
                class SamplePtr {

                  // Default constructor
                  constexpr SamplePtr() noexcept;

                  // semantically equivalent to Default constructor
                  constexpr SamplePtr(nullptr\_t) noexcept;

                  // Copy constructor is deleted
                  SamplePtr ( const SamplePtr& ) = delete;

                  // Move constructor
                  SamplePtr( SamplePtr&& ) noexcept;

                  // Default copy assignment operator is deleted
                  SamplePtr& operator=( const SamplePtr& ) = delete;

                  // Assignment of nullptr\_t
                  SamplePtr& operator=(nullptr\_t) noexcept;

                  // Move assignment operator
                  SamplePtr& operator=( SamplePtr&& ) noexcept;

                  // Dereferences the stored pointer
                  T& operator() const noexcept;
                  T operator->() const noexcept;

                  //Checks if the stored pointer is null
                  explicit operator bool () const noexept;

                  // Swaps the managed object
                  void Swap ( SamplePtr& ) noexcept;

                  //Replaces the managed object
                  void Reset (nullptr\_t) ;

                  //Returns the stored object
                  T Get () const noexcept;

                };}}}

                Note. The dereference operator {{T& operator() const noexcept}} will only be defined when the template type {{T}} of the SamplePtr is not {{void}}.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.UseProgrammingLanguageInfrastructure@1, Communication.ZeroCopy@1]
                version = 1
            }

            /* broken_link_c/issue/21470937 */
            ScoreReq.CompReq SampleAllocateePtr {
                description = '''{{mw::com}}sample allocated by the binding. shall provide the definition of {{SampleAllocateePtr}} as a pointer to a data

                The public interface shall at least provide the following interface:

                {{{template< typename T >
                class SampleAllocateePtr {

                  // Default constructor
                  constexpr SampleAllocateePtr() noexcept;

                  // semantically equivalent to Default constructor
                  constexpr SampleAllocateePtr(std::nullptr\_t) noexcept;

                  // Copy constructor is deleted
                  SampleAllocateePtr( const SampleAllocateePtr& ) = delete;

                  // Move constructor
                  SampleAllocateePtr( SampleAllocateePtr&& ) noexcept;

                  // Default copy assignment operator is deleted
                  SampleAllocateePtr& operator=( const SampleAllocateePtr& ) = delete;

                  // Assignment of nullptr\_t
                  SampleAllocateePtr& operator=(std::nullptr\_t) noexcept;

                  // Move assignment operator
                  SampleAllocateePtr& operator=( SampleAllocateePtr&& ) noexcept;

                  // Dereferences the stored pointer
                  T& operator() const noexcept;
                  T operator->() const noexcept;

                  //Checks if the stored pointer is null
                  explicit operator bool () const noexept;

                  // Swaps the managed object
                  void Swap ( SampleAllocateePtr& ) noexcept;

                  //Returns the stored object
                  T Get () const noexcept;

                };}}}'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ZeroCopy@1]
                version = 1
            }

            section "InstanceSpecifier" {

                /* broken_link_c/issue/18443828 */
                ScoreReq.CompReq InstanceSpecifierCreate {
                    description = '''The {{InstanceSpecifier}}

                     class shall provide a non-throwing constructor using the Named Constructor idiom (See progress-cursor Creation of an object using Named Constructor approach

                    {{{static bmw::Result<InstanceSpecifier> InstanceSpecifier::Create(amp::string\_view shortname\_path) noexcept;}}}

                    Arguments:

                    *  shortname\_path: a shortname path whose behaviour is described in Shortname path.

                    Return value: returned {{bmw::Result}} which contains

                    *  a {{bmw::Result::Error}} containing the value {{ComErrc::kInvalidMetaModel}} Shortnamewhen {{shortname\_path}} doesn't adhere to the specifications described in Shortname path.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18442825 */
                ScoreReq.CompReq InstanceSpecifierConstructor {
                    description = '''The constructor of the class {{InstanceSpecifier}}
                    shall be private.

                    Note: Construction of an {{InstanceSpecifier}} instance by the user shall only be possible via the public static {{Create()}} method (See InstanceSpecifier Create).

                    Therefore the signature of the constructor of {{InstanceSpecifier}} is implementation defined.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18442922 */
                ScoreReq.CompReq InstanceSpecifierCopySemantics {
                    description = '''The {{InstanceSpecifier}}
                    class shall be copy-constructible as well as being copy-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/21355358 */
                ScoreReq.CompReq InstanceSpecifierMoveSemantics {
                    description = '''The {{InstanceSpecifier}}
                    class shall be move-constructible as well as being move-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForProgrammingLanguageIdioms@1, Communication.SupportForMultipleProgrammingLanguages@1]
                    version = 1
                }

                /* broken_link_c/issue/18443704 */
                ScoreReq.CompReq InstanceSpecifierComparisonOperators {
                    description = '''The {{InstanceSpecifier}} class shall provide a {{operator==}} function for the following:

                    * {{InstanceSpecifier}}and {{InstanceSpecifier}}

                    * {{InstanceSpecifier}}{{amp::string\_view}}
                     and
                    * {{amp::string\_view}}{{InstanceSpecifier}} and

                    Return value: {{true}}{{short-name-path}}{{false}} if both the left and right sides are denoting exactly the same element via an identical AUTOSAR  Otherwise,  .

                    The {{InstanceSpecifier}} class shall provide a {{operator!=}} function for the following:

                    *  {{InstanceSpecifier}}and {{InstanceSpecifier}}

                    *  {{InstanceSpecifier}}{{amp::string\_view}} and

                    *  {{amp::string\_view}}{{InstanceSpecifier}} and

                    Return value: the negation of the {{operator==}} function taking the left and right sides.

                    The {{InstanceSpecifier}} class shall provide a {{operator<}} function for two {{InstanceSpecifier}}s.

                    Return value: {{true}} if the underlying string of the first {{InstanceSpecifier}} is lexically smaller than underlying string of the second one. Otherwise,{{false}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/21777400 */
                ScoreReq.CompReq InstanceSpecifierHashOperator {
                    description = '''An overload for {{std::hash}} for {{InstanceSpecifier}} which allows hashing an {{InstanceSpecifier}} shall be provided. An {{InstanceSpecifier}} shall be able to be used as a key in STL containers such as {{std::map}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18444700 */
                ScoreReq.CompReq InstanceSpecifierToString {
                    description = '''The {{InstanceSpecifier}} class shall provide a public method:

                    {{{amp::string\_view InstanceSpecifier::ToString() const noexcept;}}}

                    Return value: a stringified form of {{InstanceSpecifier}}. {{amp::string\_view}}{{InstanceSpecifier}}The lifetime of the underlying string of the returned  is guaranteed for the lifetime of the '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/21361782 */
                ScoreReq.CompReq InstanceSpecifierCorrespondenceToServiceInstances {
                    description = '''A valid {{InstanceSpecifier}} can correspond to 1..n service instances.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ServiceInstance@1]
                    version = 1
                }

                /* broken_link_c/issue/31484351 */
                ScoreReq.CompReq InstanceSpecifierMultiBinding {
                    description = '''Each of the instances that an {{InstanceSpecifier}} corresponds to may be of a different binding. Multiple instances can also correspond to the same binding.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.MultiBindingSupport@1]
                    version = 1
                }
            }

            section "InstanceIdentifier" {

                /* broken_link_c/issue/18448357 */
                ScoreReq.CompReq InstanceIdentifierCreate {
                    description = '''The {{InstanceIdentifier}} class shall provide a non-throwing constructor using the Named Constructor idiom (See progress-cursor Creation of an object using Named Constructor approach

                    {{{static bmw::Result<InstanceIdentifier> InstanceIdentifier::Create(amp::string\_view serialized\_format) noexcept;}}}

                    Arguments:

                    * serialized\_format: The serialized form of an {{InstanceIdentifier}} that has been created using InstanceIdentifier ToString.

                    Return value: returned {{bmw::Result}} which contains

                    *  a {{bmw::Result::Error}} containing the value {{ComErrc::kInvalidInstanceIdentifierString}}. when the format of the {{serialized\_format}} is corrupted'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18448416 */
                ScoreReq.CompReq InstanceIdentifierConstructor {
                    description = '''The constructor of the class {{InstanceIdentifier}}
                    shall be private.

                    Note: Construction of an {{InstanceIdentifier}}instance by the user shall only be possible via the public static {{Create()}} method (See  InstanceIdentifier Create).

                    Therefore the signature of the constructor of {{InstanceIdentifier}}is implementation defined. '''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18563675 */
                ScoreReq.CompReq InstanceIdentifierCopySemantics {
                    description = '''The {{InstanceIdentifier}}
                    class shall be copy-constructible as well as being copy-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.DataLoss@1]
                    version = 1
                }

                /* broken_link_c/issue/21353341 */
                ScoreReq.CompReq InstanceidentifierMoveSemantics {
                    description = '''The {{InstanceIdentifier}}
                    class shall be move-constructible as well as being move-assignable.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForProgrammingLanguageIdioms@1, Communication.SupportForMultipleProgrammingLanguages@1]
                    version = 1
                }

                /* broken_link_c/issue/17556907 */
                ScoreReq.CompReq InstanceIdentifierComparisonOperators {
                    description = '''The {{InstanceIdentifier}}
                    {{operator==}}
                     class shall provide a  function for the following:

                    *  {{InstanceIdentifier}}and {{InstanceIdentifier}}

                    *  {{InstanceIdentifier}}{{amp::string\_view}} and

                    *  {{amp::string\_view}}{{InstanceIdentifier}} and

                    Return value: {{true}}{{short-name-path}}{{false}} if both the left and right sides are denoting exactly the element via an identical AUTOSAR  Otherwise,  .

                    The {{InstanceIdentifier}} class shall provide a {{operator!=}} function for the following:

                    *  {{InstanceIdentifier}}and {{InstanceIdentifier}}

                    *  InstanceIdentifier}}{{amp::string\_view}} and

                    *  amp::string\_view}}{{InstanceIdentifier}} and

                    Return value: the negation of the {{operator==}} function taking the left and right sides.

                    The {{InstanceIdentifier}} class shall provide a {{operator<}} function for two {{InstanceIdentifier}}s.

                    Return value: {{true}} if the underlying string of the first {{InstanceIdentifier}} is lexically smaller than underlying string of the second one. Otherwise,{{false}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18448382 */
                ScoreReq.CompReq InstanceIdentifierToString {
                    description = '''The {{InstanceIdentifier}} class shall provide a public method:

                    {{{amp::string\_view InstanceIdentifier::ToString() const noexpect;}}}

                    Return value: a stringified form of {{InstanceIdentifier}}. The lifetime of the underlying string of the returned {{amp::string\_view}} is guaranteed for the lifetime of the {{InstanceIdentifier}}.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/21361788 */
                ScoreReq.CompReq InstanceidentifierCorrespondencetoserviceinstances {
                    description = '''A valid {{InstanceIdentifier}} can correspond to 1..n service instances. Each of the instances shall be of the same binding.'''
                    safety = ScoreReq.Asil.B
                    derived_from = [Communication.ServiceInstance@1]
                    version = 1
                }

            /* broken_link_c/issue/21784908 */
            ScoreReq.CompReq InstanceIdentifierContainer {
                description = '''{{mw::com}} shall provide a class {{InstanceIdentifierContainer}} in namespace {{bmw::mw::com}}, which acts as a container for instances of InstanceIdentifier Class

                {{InstanceIdentifierContainer}} must adhere to the named requirements of a sequence container requirements according to [C++ named requirements: SequenceContainer|https://en.cppreference.com/w/cpp/named\_req/SequenceContainer]
                A {{std::vector}} for example fulfills these requirements.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                version = 1
            }

            /* broken_link_c/issue/21789762 */
            ScoreReq.CompReq FindServiceHandle {
                description = '''{{mw::com}} shall provide a type {{FindServiceHandle}} in the namespace {{bmw::mw::com}}.

                A {{FindServiceHandle}} shall be able to identify unambigously a started search for available service instances via:

                * xxx or GenericProxy StartFindService with InstanceSpecifier,

                , so that the started search can be stopped again via:

                * xxx or yyy.

                {{FindServiceHandle}} shall satisfy the `EqualityComparable <https://en.cppreference.com/w/cpp/named\_req/EqualityComparable>`\_  named requirement of C++.

                {{FindServiceHandle}} shall satisfy the `LessThanComparable <https://en.cppreference.com/w/cpp/named\_req/LessThanComparable>`\_  named requirement of C++.

                {{FindServiceHandle}} shall satisfy the `CopyAssignable <https://en.cppreference.com/w/cpp/named\_req/CopyAssignable>`\_  named requirement of C++.

                to allow storing and managing FindServiceHandles in C++ container classes by the using application.

                These requirements are fulfilled if the following operators are provided: operator==, operator<, and operator=.

                The exact definition of {{FindServiceHandle}} is {{mw::com}} implementation specific.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/21791066 */
            ScoreReq.CompReq FindServiceHandler {
                description = '''{{mw::com}} shall provide the definition of {{FindServiceHandler}} in namespace {{bmw::mw::com}} as a function wrapper for the user provided handler function that gets called by the {{mw::com}} implementation in case the currently available service instances for a given asynchronous search has changed. The user must provide the function implementation which is not required to be re-entrant for a given registration.

                I.e. the mw::com implementation assures call serialization to an FindServiceHandler instance for a given started asynchronous search identified by a FindServiceHandle.

                The signature of a {{FindServiceHandler}} is:

                {{void(bmw::mw::com::ServiceHandleContainer, bmw::mw::com::FindServiceHandle)>;}}

                Arguments:

                * {{ServiceHandleContainer}}: container of HandleType, representing the currently available service instances matching the given search.

                * {{FindServiceHandle}}: The FindServiceHandle representing the search, where the availability of service instances has changed.

                The type chosen for {{FindServiceHandler}} by the {{mw::com}} provider shall allow construction from any callable, with the given signature.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                version = 1
            }
            }
        }

        section "Runtime" {

            /* broken_link_c/issue/21781439 */
            ScoreReq.CompReq RuntimeResolveInstanceIDs {
                description = '''A function:

                {{bmw::Result<InstanceIdentifierContainer> ResolveInstanceIDs(mw::com::InstanceSpecifier instance\_specifier)}}

                shall exist in the namespace {{bmw::mw::com::runtime}}.

                Arguments:

                {{instance\_specifier}}: an instance specifier denoting a service instance from the model.

                Return value: returned {{bmw::Result}} which contains

                * a {{bmw::Result::Error}} containing the value {{ComErrc::kInstanceIDCouldNotBeResolved}}, when the instance\_specifier could not be resolved in the configuration.

                * or, a {{bmw::Result::Value}} containing an {{InstanceIdentifierContainer}} with all the {{InstanceIdentifier}}s configured for the given {{instance\_specifier}}.

                Thread-safety: {{ResolveInstanceIDs}} shall be thread-safe (opposed to the general requirement Thread-safety of methods/functions of Public API)'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.DeploymentConfigurationAtRuntime@1]
                version = 1
            }
        }
    }

    section "Referenced_Requirements" {

        /* broken_link_c/issue/17435062 */
        ScoreReq.CompReq CreationOfAnObjectUsingNamedConstructorApproach {
            description = '''A class, {{MyClass}}, shall provide a static member function {{Create()}} returning the constructed object embedded in a {{bmw::Result}}. This function first performs all operations for constructing an object of {{MyClass}}, which may fail or result in an error. E.g. parameter checks or resource allocation may fail.

            If an error occurs during these operations, the error is returned as an {{bmw::result::ErrorCode}} in the {{bmw::Result}}. If no error occurs, the created object is returned as a value in the {{bmw::Result}}. The value object can then be considered as valid. The function shall not throw an exception.

            {{{static bmw::Result<MyClass::Create(/ construction arguments /) noexcept;}}}'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ErrorHandling@1, Communication.SupportForProgrammingLanguageIdioms@1]
            version = 1
        }

        /* broken_link_c/issue/21292772 */
        ScoreReq.CompReq ReEntrancyAndThreadSafety {
            description = '''A class, {{MyClass}}, {{MyClass}}shall be re-entrant and thread-safe for different  class instances. When called re-entrant or concurrently on the same {{MyClass}} instance, the behavior is undefined.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/21270100 */
        ScoreReq.CompReq ReturnValueOfSubscribe {
            description = '''If {{Subscribe()}} has already been called on the event (and hasn't been withdrawn with a call to {{Unsubscribe()}}), when {{Subscribe()}} is called, and the provided {{max\_sample\_count}} value is:

            *  the same as for the current subscription, then {{Subscribe()}} shall return silently without any action.

            *  {{Subscribe()}}different from the value for the current subscription, then  shall return {{bmw::result::ErrorCode}} containing the value {{ComErrc::kMaxSampleCountNotRealizable}} .a '''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/21269964 */
        ScoreReq.CompReq BehaviourOfSubscribe {
            description = '''Subscribe will begin the synchronous subscription process according to progress-cursor SubscriptionState. The subscription process can be rejected by the provider side if:

            *  the provider doesn't have sufficient resources to satisfy the {{max\_sample\_count}} requested according to Oversubscription of an Event only possible if configured.

            *  if the total number of allowable subscribers is exceeded.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/21286218 */
        ScoreReq.CompReq BehaviourOfUnsubscribe {
            description = '''If the subscription process hasn't already started (i.e. {{Subscribe()}} hasn't been called before), {{Unsubscribe()}} shall return silently without any action.

            Otherwise it shall do an unsubscription of the event at the providing side.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/21293087 */
        ScoreReq.CompReq BehaviourOfSetReceiveHandler {
            description = '''The {{EventReceiveHandler}} that is passed to {{SetReceiveHandler}} shall be called every time data is received by the class instance on which {{SetReceiveHandler}} is called.

            {{SetReceiveHandler}} shall adhere to the re-entrancy and thread-safety specifications described in Re-entrancy and Thread-safety.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.EventType@1]
            version = 1
        }

        /* broken_link_c/issue/21293524 */
        ScoreReq.CompReq BehaviourOfUnsetReceiveHandler {
            description = '''{{UnsetReceiveHandler}} will unregister the {{EventReceiveHandler}} that was registered by the class instance with a call to {{SetReceiveHandler}}. After calling {{UnsetReceiveHandler}}, the {{EventReceiveHandler}} will no longer be triggered when the class instance receives new data.

            {{UnsetReceiveHandler}} shall fulfill the following requirement: Explicit Lifetime ending by API calls

            {{UnsetReceiveHandler}} shall adhere to the re-entrancy and thread-safety specifications described in Re-entrancy and Thread-safety.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.EventType@1]
            version = 1
        }

        /* broken_link_c/issue/21293991 */
        ScoreReq.CompReq ReturnValueOfGetFreeSampleCount {
            description = '''The returned {{size\_t}}
             returned from {{GetFreeSampleCount}} indicates the number of free/unused slots for data samples in the local cache.

            {{GetFreeSampleCount}} .shall adhere to the re-entrancy and thread-safety specifications described in default-cursor Re-entrancy and Thread-safety'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/21294278 */
        ScoreReq.CompReq BehaviourOfGetNumNewSamplesAvailable {
            description = '''{{GetNumNewSamplesAvailable}} queries the number of new data samples that are available since the last time {{GetNewSamples}} was called on the class instance that {{GetNumNewSamplesAvailable}} was called on.

            {{GetNumNewSamplesAvailable}} .shall adhere to the re-entrancy and thread-safety specifications described in Re-entrancy and Thread-safety'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/14035773 */
        ScoreReq.CompReq BehaviourOfGetNewSamples {
            description = '''{{GetNewSamples}} updates the local event cache with new data samples that are available {{GetNewSamples}}since the last call to on the same class instance.

            In the context of the {{GetNewSamples}} call, the following steps shall be done repeatedly:

            * get next received event data sample from underlying receive buffers in FIFO semantics. I.e. first received sample is first to be taken.

            *  de-serialize the data, if needed.

            * place the data sample of type {{SampleType}}in the local cache.

            * call user provided callback {{f}} with a {{SamplePtr}} referencing the data sample located in local cache (See SamplePtr).

            until at least one of the following conditions is true:

            * {{max\_num\_samples}} have already been fetched from the underlying receive buffers within this {{GetNewSamples}} call.

            * {{max\_num\_samples}} reached. I.e. the application is currently holding exactly as many {{SamplePtr}}s provided by this Event class instance, as it has committed in call to {{Subscribe}} via {{max\_sample\_count}}.

            * no new data samples available from underlying receive buffers.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/22128594 */
        ScoreReq.CompReq BehaviourOfOfferService {
            description = '''When {{OfferService}} has returned, the service instance shall be visible to potential consumers such that they are able to find it via a call to {{FindService}} or {{StartFindService}} on any {{Proxy}} or {{GenericProxy}}.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ServiceDiscovery@1]
            version = 1
        }

        /* broken_link_c/issue/22121224 */
        ScoreReq.CompReq BehaviourOfStopOfferService {
            description = '''When {{StopOffer}} has returned, any call to {{FindService}}{{StartFindService}}{{Proxy}}{{GenericProxy}} won't find / return this instance. or  on any  or

            Existing proxies of this service instance:

            *  will see a SubscriptionState change for any {{Event}} / {{Field}}, which were previously in state {{kSubscribed}}.

            *  which are currently processing a service method call will return a failure in the method call.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ServiceDiscovery@1]
            version = 1
        }

        /* broken_link_c/issue/21350367 */
        ScoreReq.CompReq ReturnValueOfSuccessfulGetNewSamples {
            description = '''On success, {{GetNewSamples}} will return the {{receiver}}{{GetNewSamples}}number of data samples that were passed to the  function (that was passed to {{GetNewSamples}}) in the context of the  call.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/14086929 */
        ScoreReq.CompReq GetNewSamplesReceiverSignature {
            description = '''The user provided Callable {{receiver}} in calls to {{GetNewSamples}} has to comply with the following signature:

            {{{void(mw::com::SamplePtr<SampleType>)}}}'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/21803116 */
        ScoreReq.CompReq CalculationOfFreeSampleCount {
            description = '''
            * After call to {{Subscribe}} (ProxyEvent Subscribe or GenericProxyEvent Subscribe) with parameter {{maxSampleCount}} set to N and before any call to {{GetNewSamples}} on the same Event class instance, a call to {{GetFreeSampleCount}} shall return N.

            * Each SamplePtr created by the {{mw::com}} implementation in the context of a call to {{GetNewSamples}} on the same Event class instance. shall lead to a decrement of count of free samples.

            * Each destruction or {{nullptr\_t}} assignment of a SamplePtr instance created from this Event class instance shall lead to a increment of count of free samples.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/21361285 */
        ScoreReq.CompReq shortnamePath {
            description = '''An shortname is a string which follows the following rules:

            * The first character of a shortname must be one of the following:

              *  uppercase Latin letters A-Z

              *  lowercase Latin letters a-z

              *  underscore

            * Any other character of a must be one of the following:
            shortname
              *  digits 0-9

              *  uppercase Latin letters A-Z

              *  lowercase Latin letters a-z

              *  underscore

            *  A shortname path is a sequence of shortnames delimited by {{/}}.

            Note. The concept and definition of a shortname path is based on AUTOSAR shortname paths and the naming convention is .derived from the rule for C++ Identifiers'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/18804932 */
        ScoreReq.CompReq BehaviourOfFindService {
            description = '''{{FindService}} will return handles for all available service instances corresponding to  / the InstanceSpecifier ClassInstanceIdentifier Class from which a fully working Proxy Class or GenericProxy Class can be constructed. A service instance is available if:

            * Skeleton OfferService has been called on the provider side

            * and not yet been withdrawn with Skeleton StopOfferService

            The correspondence between service instances and an:

            * {{InstanceSpecifier}}   is described in InstanceSpecifier Correspondence to Service Instances .

            * InstanceIdentifier}} is described in InstanceIdentifier Correspondence to Service Instances'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ServiceDiscovery@1]
            version = 1
        }

        /* broken_link_c/issue/21788845 */
        ScoreReq.CompReq BehaviourOfStartFindService {
            description = '''{{StartFindService}} service instances corresponding to the will start an asynchronous search for all available InstanceSpecifier/InstanceIdentifier from which a fully working Proxy Class or GenericProxy Class can be constructed. A service instance is available if:

            *  Skeleton OfferService has been called on the provider side

            *  and not yet been withdrawn with Skeleton StopOfferService

            The correspondence between service instances and an:

            * {{InstanceSpecifier}}   is described in InstanceSpecifier Correspondence to Service Instances .

            * InstanceIdentifier}} is described in InstanceIdentifier Correspondence to Service Instances

            Whenever the availability of available service instances changes (i.e. new instances showing up, previous instances offering stopped), the given {{FindServiceHandler}} gets called with the current list of available service instances, until {{StopFindService}} (See Proxy StopFindService / GenericProxy StopFindService) has been called with the returned {{FindServiceHandle}}.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ServiceDiscovery@1]
            version = 1
        }

        /* broken_link_c/issue/21466369 */
        ScoreReq.CompReq BehaviourOfSetSubscriptionStateChangeHandler {
            description = '''The {{SubscriptionStateChangeHandler}} (See SubscriptionStateChangeHandler)
            {{SetSubscriptionStateChangeHandler}}
            that is passed to shall be called every time the {{SubscriptionState}} (See SubscriptionState) changes according to the requirements:

            *  Calls to SubscriptionStateChangeHandler with kSubscriptionPending

            *  Calls to SubscriptionStateChangeHandler with kSubscribed

            *  Calls to SubscriptionStateChangeHandler with kNotSubscribed'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/18805834 */
        ScoreReq.CompReq CallsToSubscriptionStateChangeHandlerWithKNotSubscribed {
            description = '''{{mw::com}} shall call a registered {{SubscriptionStateChangeHandler}} for an event or field instance, with the value {{kNotSubscribed}} in the following cases:

            * the client unsubscribes to an event or field and the unsubscription is established successfully

            * the client had issued a subscription to an event or field and the related SubscriptionState was already in state {{kSubscriptionPending}} or {{kSubscribed}}, but then the provider side decided to refuse/abort/withdraw the subscription for at least the remaining lifetime of the providing side service instance.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/18805769 */
        ScoreReq.CompReq CallsToSubscriptionStateChangeHandlerWithkSubscriptionPending {
            description = '''{{mw::com}} shall call a registered {{SubscriptionStateChangeHandler}} for an event or field instance, with the value {{kSubscriptionPending}} in the following cases:

            * the client subscribes to an event or field and the actual subscription does not happen immediately (e.g. due to a bus protocol)

            * the client is subscribed to an event or field and {{mw::com}} implementation has detected, that the server instance is currently not available (due to restart, network problem or other reasons)'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/18805778 */
        ScoreReq.CompReq SubscriptionStateChangeHandlerWithKSubscribed {
            description = '''{{mw::com}} shall call a registered {{SubscriptionStateChangeHandler}} for an event or field instance, with the value {{kSubscribed}} in the following cases:

            * the client subscribes to an event or field and the actual subscription is established successfully

            * the client is subscribed to an event or field and the actual subscription is re-established again after being temporarily unavailable (due to restart, network problem or other reasons)'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/21466236 */
        ScoreReq.CompReq BehaviourOfUnsetSubscriptionStateChangeHandler {
            description = '''{{UnsetSubscriptionStateChangeHandler}} {{UnsetSubscriptionStateChangeHandler}}{{SubscriptionStateChangeHandler}}will unregister the {{SubscriptionStateChangeHandler}} (See SubscriptionStateChangeHandler) that was registered by the class instance with a call to {{SetSubscriptionStateChangeHandler}} After calling  the  will no longer be triggered when the {{SubscriptionState}} (See progress-cursor SubscriptionState changes.

            {{UnsetSubscriptionStateChangeHandler}} shall fulfill the following requirement: Explicit Lifetime ending by API calls.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ProducerConsumerPattern@1]
            version = 1
        }

        /* broken_link_c/issue/21470600 */
        ScoreReq.CompReq BehaviourOfAllocate {
            description = '''The {{Allocate}} method of the specific class allows the binding to allocate memory and provide a {{SampleAllocateePtr}} (See SampleAllocateePtr) which can be filled by the user.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/21553375 */
        ScoreReq.CompReq BehaviourOfUpdateSendWithCopy {
            description = '''{{mw::com}} creates a copy of input parameter and shares it with all subscribed applications.

            Note. In certain cases, the error handling of {{Update}} may be deferred according to Deferring Initial Value Update Error Handling to OfferService
            '''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.EventType@1]
            version = 1
        }

        /* broken_link_c/issue/21553623 */
        ScoreReq.CompReq BehaviourOfZeroCopyUpdateSend {
            description = '''Before updating/sending a field or event, a slot in memory must be requested with SkeletonField class Allocate
             resp. SkeletonEvent class Allocate and filled with the respective data. The data will then be shared with all subscribed applications.

            Note. In certain cases, the error handling of {{Update}} may be deferred according to Deferring Initial Value Update Error Handling to OfferService.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ZeroCopy@1]
            version = 1
        }

        /* broken_link_c/issue/22129134 */
        ScoreReq.CompReq BehaviourOfSettingFieldInitialValue {
            description = '''If SkeletonField class Update or SkeletonField class Zero-copy Update are called multiple times before Skeleton OfferService, then the value from the latest {{Update}} call will be used to set the initial value of the field.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/21553554 */
        ScoreReq.CompReq DeferringInitialValueUpdateErrorHandlingToOfferService {
            description = '''Depending on the binding implementation, when SkeletonField class Update or SkeletonField class Zero-copy Update

            is is called before Skeleton OfferService
            {{Skeleton}}
            {{SkeletonField}}
            {{Update}}
            {{OfferService}}
             is called on the  containing the  the handling of an error from the  call, and subsequently the returning of the error code, may be deferred to the  call.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ErrorHandling@1]
            version = 1
        }
    }

    section "Functionality" {

        /* broken_link_c/issue/8742625 */
        ScoreReq.CompReq CheckTheUidOfTheProducer {
            description = '''A consumer consuming a provided service instance in the role of a proxy shall verify, whether the UID of the service instance provider matches its configured expectation. If the UID of the provider does not match the expectation, the consumer shall reject the communication with this provided service instance.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/5898654 */
        ScoreReq.CompReq OperateLoLaInParallelToAdaptiveAutosar {
            description = '''It shall be possible to compile / link / operate LoLa in parallel to an adaptive AUTOSAR Stack.

            Note:

            This includes that one process (one adaptive Application) shall be able to use ara::com and LoLa in parallel.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@2]
            version = 1
        }

        /* broken_link_c/issue/5898898 */
        ScoreReq.CompReq UseBmwSpecificNamespace {
            description = '''LoLa shall not operate in the {{ï»¿ara}} C++ namespace. Any {{ara}} specific namespace descriptions in adaptive AUTOSAR Communication Management shall by customized to a BMW specific one.

            Note:

            In order to operate LoLa in parallel to any adaptive AUTOSAR Stack, we need to ensure, that there are no type clashes and therefore we use a distinct/separate namespace.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5898932 */
        ScoreReq.CompReq UserDataShallBeExchangedViaSharedMemory {
            description = '''Data that is send by a user, via a skeleton, shall only be transmitted via Shared Memory.

            Note:
            Only this way we can ensure zero-copy capabilities.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5898962 */
        ScoreReq.CompReq NotificationsShallBeExchangedViaMessagePassing {
            description = '''Any high-level notifications (e.g. subscription, event ready) shall be exchanged via Message Passing.

            Note:

            This way no blocking communication needs to be implemented via Shared Memory. Easing FFI argumentation.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899052 */
        ScoreReq.CompReq UserDataShallBeProvidedInASeparateReadOnlySharedMemorySegment {
            description = '''User data (see User data shall be exchanged via Shared Memory) shall be provided in a separate read-only shared memory segment.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899059 */
        ScoreReq.CompReq OneSharedMemorySegmentPerASILLevelForControlData {
            description = '''For each communication channel a different shared memory segment shall be used per ASIL.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899076 */
        ScoreReq.CompReq TheSharedMemorySegmentsShallBeDividedIntoSlots {
            description = '''The shared memory segments (defined in User data shall be provided in a separate read-only shared memory segment and One shared memory segment per ASIL level for control data) shall be divided into slots.

            A specific slot N in a data segment shall refer to a specific slot N in a control segment.

            Note:
            It might be necessary to add some further meta information of the shared memory segment  into it. So this does not indicate that the whole shared memory segment is split only into slots.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899090 */
        ScoreReq.CompReq TheNumberOfSlotsShallBeConfigurable {
            description = '''The number of available slots (defined here: The shared memory segments shall be divided into slots) shall be configurable.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899126 */
        ScoreReq.CompReq CalculateNecessarySharedMemorySizePriorToCreatingIt {
            description = '''A skeleton process shall calculate the necessary shared memory size for the control and data segments, prior to creating it.

            Note:
            A maximum limit of elements needs to be given and a data structure must not reallocate during sample assembly. Otherwise we might run out of memory due to fragmentation, even with more advanced allocation schemes.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899136 */
        ScoreReq.CompReq LolaSharedMemorySegmentsUsedByMwComShallStartWithPrefixLola {
            description = '''Shared Memory segments used by mw::com (aka LoLa) shall start with prefix `lola`'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899143 */
        ScoreReq.CompReq FilesThatAreUsedForSharedMemoryIpcShallNotBePersistent {
            description = '''Shared Memory segments that are used for IPC communication in the sense of LoLa shall not be persistent. This means that producers that create shared memory segments shall remove them on destruction.

            Underlying files shall only be finally removed from the file-system once no consumer access them anymore.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899159 */
        ScoreReq.CompReq SharedMemorySegmentsShallBeIdentifiedViaACommonKnownName {
            description = '''A consumer (proxy) and a producer (skeleton) shall identify a to-be-used shared memory segment via a common known name.

            Note:

            This name might be subject to calculation by deployment variables. e.g. a service id or instance id'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899160 */
        ScoreReq.CompReq ThereShallBeOneTripletOfSharedMemorySegmentsPerServiceInstance {
            description = '''The shared memory segments described in The shared memory segments shall be divided into slots and One shared memory segment per ASIL level for control data shall exist per service instance.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899175 */
        ScoreReq.CompReq SharedMemorySegmentsShallNotBeMappedToAFixedVirtualAddress {
            description = '''Shared Memory segments shall not be mapped to a fixed virtual address.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899178 */
        ScoreReq.CompReq OnlyOffsetPointerWithinSharedMemorySegments {
            description = '''There shall be no usage of any other pointer type then offset pointer (aka fancy pointer, aka relative pointer) within a shared memory segment.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899184 */
        ScoreReq.CompReq OnlyConfiguredUidsShallHaveAccessToTheLoLaSharedMemorySegments {
            description = '''It shall be configurable which user ids have access to data and control shared memory segments.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899238 */
        ScoreReq.CompReq PerformActiveBoundCheckingOnDereferencingOfOffsetPointer {
            description = '''Any dereferenciation of an offset pointer shall be subject to active bound checking.

            Active bound checking referes to an active check, that the calculated target pointer is within the bounds of the mapped shared memory segment.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899241 */
        ScoreReq.CompReq SychronizingSharedMemoryRegionsShallEnsureWaitFreedom {
            description = '''The synchronization between data and control segments shall ensure wait-freedom.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899244 */
        ScoreReq.CompReq SubscriptionHandlingShallBeImplementedViaMessagePassing {
            description = '''Subscription handling shall be implemented via Message Passing'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899250 */
        ScoreReq.CompReq EventNotificationsShallBeImplementedViaMessagePassing {
            description = '''Event Notifications shall be implemented via Message Passing'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899262 */
        ScoreReq.CompReq OneMessagePassingReceivePortPerASILLevelPerProcess {
            description = '''There shall exist one message passing receive port for LoLa communication per ASIL per process'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899265 */
        ScoreReq.CompReq EachMessagePassingPortShallUseACustomThread {
            description = '''Each message passing port (see One message passing receive port per ASIL-Level per process) shall use a custom thread.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899276 */
        ScoreReq.CompReq RegisterACallbackForAllExchangeMessages {
            description = '''It shall be possible for all notifications (exchanged via message passing) to register a callback.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899282 */
        ScoreReq.CompReq RegisteredCallbacksForMessagesShallBeInvokedOfTheRespectiveWaitingThread {
            description = '''A user shall be able to register callbacks that are invoked on the reception of messages. These callbacks shall be invoked in the respective waiting thread.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899287 */
        ScoreReq.CompReq AControlSlotShallContainAllNecessaryDataInformationForSynchronizingDataAccess {
            description = '''A control slot shall contain all necessary data information for synchronizing data access'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899292 */
        ScoreReq.CompReq AProducerShallAlwaysBeAbleToStoreNewData {
            description = '''A producer shall always be able to store new data'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/5899299 */
        ScoreReq.CompReq OnContractViolationQmCommunicationForTheAffectedServiceInstanceShallBeWithdrawn {
            description = '''On contract violation, QM communication for the affected service instance shall be withdrawn'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/6093144 */
        ScoreReq.CompReq StopOfferingServiceDuringServiceObjectDestruction {
            description = '''If, during destruction of an object that acts as a middleware service, the service is still in an offered state, the service offering shall be stopped.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ServiceDiscovery@1]
            version = 1
        }

        /* broken_link_c/issue/7088394 */
        ScoreReq.CompReq OversubscriptionOfAnEventOnlyPossibleIfConfigured {
            description = '''Per default LoLa (mw::com) shall supervise the "maxSampleCount" arguments of all consumer side Subscribe() calls for a specific event instance.

            The sum of all "maxSampleCount" argument values of all currently active subscription must not be larger than the configured number of sample slots of the specific event instance - 1.

            If a new Subscribe() call would violate this rule, this subscription shall be rejected.

            This supervision shall be skipped, in case the configuration of the specific event instance explicitly allows an oversubscription.

            Note:

            Within the LoLa configuration it is configured/defined, what is the maximum number of (pre-allocated) sample slots per event instance.

            The generic calculation-rule for defining this number is:

            1 + Sum of "maxSampleCount" arguments of all consumer side Subscribe() calls, which are active during runtime.

            This rule is designed in a way to assure, that all consumers can hold up to their used "maxSampleCount" in subscription for an arbitrary timespan in parallel!'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }

        /* broken_link_c/issue/20003388 */
        ScoreReq.CompReq ErrorCodesRelatingToActiveSubscription {
            description = '''An {{Unsubscribe()}}When an API returning an error code is only supported  during an "Active Subscription", then the {{bmw::result::ErrorCode}} with value {{kNotSubscribed}} can be returned:Active Subscription" is the period of time in between a successful subscription and a call to

            *  when the API is called outside of an "Active Subscription"

            *  or, when the API is called inside an "Active Subscription" but the current subscription state is {{kSubscriptionPending}}, e.g. if the provider has gone down, and the binding is not able to support the API call in this state.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ErrorHandling@1]
            version = 1
        }

        /* broken_link_c/issue/20002443 */
        ScoreReq.CompReq ReturnCodeForBindingFailures {
            description = '''Any signature in the public API that has the possiblity of returning an error code (e.g. bmw::Result, bmw::ResultBlank) is allowed to return{{bmw::result::ErrorCode}}{{mw::com::ComErrorDomain}} and the value is set to {{kBindingFailure}}, when any failure occurs in the binding. a  where the error domain is set to '''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.ErrorHandling@1]
            version = 1
        }

        /* broken_link_c/issue/21802628 */
        ScoreReq.CompReq ThreadSafetyOfMethodsFunctionsOfPublicAPI {
            description = '''Generally all methods/functions of the public API of {{mw::com}} shall be thread-safe in case they are called on different instances.

            Generally all methods/functions of the public API of {{mw::com}} are not thread-safe in case they are called on the same instance.

            Exceptions to these rules shall be given individually per method/function.

            {{static}} (class level) methods/functions are generally not thread-safe (for the same class) unless specified otherwise.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/20236346 */
        ScoreReq.CompReq ExplicitLifetimeEndingByAPICalls {
            description = '''For a callable, which has been registered by a specific static/class-level or non-static/instance-level {{registration API}}, where there also exists a corresponding {{un-registration API}}, the {{mw::com}} implementation shall assure, that there is neither an ongoing call nor a future call to the callable after the call to the {{un-registration API}} has returned.

            Note 1: This could mean, that the call to the {{un-registration API}} may block for some time or - in worst case - forever in case a user provided callback itself blocks/runs forever.

            Note 2: Generally an {{un-registration API}} in {{mw::com}} is a void function, since it is unexpected, that un-registering can fail. If for some reason un-registering fails, it will be rated as a severe internal error leading to a {{std::terminate()}} call.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/20236391 */
        ScoreReq.CompReq ImplicitLifetimeEndingByDestructionOfContext {
            description = '''If there exists a requirement for a {{mw::com}} provided class, which supports a non-static/instance-level {{registration API}} for user provided callables, that the {{un-register API}} shall be called implicitly during destruction of an instance of the class, then

            the {{mw::com}} implementation shall assure, that there is neither an ongoing call nor a future call to the callable after the {{destructor}} of this instance has returned.

            Note: This could mean, that the call to the {{destructor}} may block for some time or - in worst case - forever in case a user provided callback itself blocks/runs forever.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SafeCommunication@1]
            version = 1
        }

        /* broken_link_c/issue/21838255 */
        ScoreReq.CompReq SampleAvailabilityAfterEventReceivedHandlerCalled {
            description = '''{{mw::com}} shall assure, that the next call to {{GetNewSamples}} (ProxyEvent GetNewSamples or GenericProxyEvent GetNewSamples or ProxyField GetNewSamples) â after an Event Receive Handler has been called for a given event or field instance â will lead to at least one call to callback F with a new sample.'''
            safety = ScoreReq.Asil.B
            derived_from = [Communication.SupportForTimeBasedArchitecture@1]
            version = 1
        }
    }

    section "Functional_Specification" {

        section "IPC_Tracing" {

            section "Configuration_and_Setup" {

                /* broken_link_c/issue/18145269 */
                ScoreReq.CompReq EventLevelConfigSwitchDocumentation {
                    description = '''The documentation of the Event Level Config Switch in the schema definition, shall inform, that setting the {{numberOfIpcTracingSlots}} parameter to a value greater than 0, will enable {{IPC tracing}}. This involves internal allocation of additional slots on top of the user configured {{numberOfSampleSlots}}. In total leading to {{numberOfIpcTracingSlots + numberOfSampleSlots }}allocations.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1, Communication.EventType@1]
                    version = 1
                }

                /* broken_link_c/issue/18159418 */
                ScoreReq.CompReq FieldLevelConfigSwitchDocumentation {
                    description = '''The documentation of the Field Level Config Switch {{numberOfIpcTracingSlots}}{{IPC tracing}}additional{{numberOfSampleSlots}}{{numberOfIpcTracingSlots + numberOfSampleSlots }}in the schema definition, shall inform, that setting the  parameter to a value greater than 0, will enable  This involves internal allocation of  slots on top of the user configured  In total leading to allocations.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159242 */
                ScoreReq.CompReq DocumentationOfSupportedTracePointTypes {
                    description = '''The currently supported trace-point types by {{mw::com}}/{{LoLa}} shall be documented within the git repository location, where {{mw::com}}/{{LoLa}} user documentation is located.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18143152 */
                ScoreReq.CompReq ApplicationLevelConfigSwitch {
                    description = '''The configuration file of a {{mw::com}}/{{LoLa }}application shall provide an optional configuration property to enable/disable {{IPC Tacing}} for the {{mw::com}}/{{LoLa}} subsystem within this application

                    Note: The default name of this configuration file is {{mw\_com\_config.json}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18143480 */
                ScoreReq.CompReq BehaviourInAbsenceOfConfigSwitch {
                    description = '''If no such configuration property (see Application Level Config Switch) exists within the configuration file, {{IPC Tracing}} for {{mw::com}}/{{LoLa }}shall be turned off for this application.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/19177359 */
                ScoreReq.CompReq ApplicationLevelPropertyInstanceIdentifier {
                    description = '''The configuration file of a {{mw::com}}/{{LoLa}} application shall provide a mandatory configuration property {{application instance identifier}} for {{IPC Tracing}}. It is mandatory only if {{IPC Tracing}} property (as per Application Level Config Switch) is present in the configuration file.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18144291 */
                ScoreReq.CompReq TraceFilterConfigPath {
                    description = '''The configuration file of a {{mw::com}}/{{LoLa }}application shall provide a configuration property to define the path/location of the trace-point filter configuration to be used.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18144411 */
                ScoreReq.CompReq DefaultTraceFilterConfigPath {
                    description = '''If {{IPC Tracing}} is turned on (Application Level Config Switch) and no path/location of the trace-point filter configuration is defined, a default location {{./etc/mw\_com\_trace\_filter.json}} is assumed, where this path is relative to the application-process current working directory.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18144499 */
                ScoreReq.CompReq FormatOfTraceFilterConfig {
                    description = '''The format of the trace-point filter configuration is a json-representation and has to follow the json-schema defined here:

                    `<broken_link_g/swh/ddad\_platform/tree/master/.github/json-schemas/comtrace\_config.json>`\_

                    Note: The schema is located in the same GIT repo as the {{mw::com}}/{{LoLa}} implementation. An {{mw::com}}/{{LoLa}} implementation in a specific branch, shall support always the schema from the same branch.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18144675 */
                ScoreReq.CompReq EventLevelConfigSwitch {
                    description = '''The configuration file of a {{mw::com}}/{{LoLa}} application shall provide an optional configuration property of type unsigned integer for an event instance, which defines, how many tracing slots should be reserved for it.

                    A value of {{0}} implicitly means, that {{IPC Tracing }}shall be disabled for the given event instance.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18144767 */
                ScoreReq.CompReq DefaultEventLevelConfigSwitch {
                    description = '''If the configuration property Event Level Config Switch is not configured for an event instance, its default value shall be {{0}}.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159398 */
                ScoreReq.CompReq FieldLevelConfigSwitch {
                    description = '''The configuration file of a {{mw::com}}
                    {{LoLa}}
                    application shall provide an optional configuration property of type unsigned integer for a field instance, which defines, how many tracing slots should be reserved for it.

                    A value of {{0}} implicitly means, that {{IPC Tracing}} shall be disabled for the given field instance.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159385 */
                ScoreReq.CompReq DefaultFieldLevelConfigSwitch {
                    description = '''If the configuration property Field Level Config Switch is not configured for a field instance, its default value shall be {{0}}.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159104 */
                ScoreReq.CompReq ProcessingTraceFilterConfig {
                    description = '''If the trace filter configuration file (see Trace Filter Config Path) could not be successfully opened or parsed (according to the underlying schema specified in Format of Trace Filter Config), then a corresponding error log message shall be created and {{IPC Tracing}} shall be turned off.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159173 */
                ScoreReq.CompReq SchemaValidationFailure {
                    description = '''If a schema-violation of the schema for the trace filter confifg (see Format of Trace Filter Config) is detected during processing/parsing of the trace filter config, an error log message shall be created and {{IPC Tracing}} shall be turned off.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159207 */
                ScoreReq.CompReq IgnoreUnsupportedTracePointTypes {
                    description = '''Trace-points within the trace filter configuration, which are enabled, but are of a type, which isn't supported by {{mw::com}}/{{LoLa}}, shall be ignored.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159328 */
                ScoreReq.CompReq TraceFilterConfigReferenceToNonExistingTracePoint {
                    description = '''If the Trace Filter Config contains a trace-point, which references an {{ara::com}}/{{mw::com}} artefact (event, field, service-method), which doesn't exist within the application, this trace-point shall be silently ignored.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159594 */
                ScoreReq.CompReq MismatchTracePointConfigWithApplicationConfig {
                    description = '''In case the trace filter config contains an enabled trace-point for a specific event or field, but the application config has disabled {{IPC Tracing}} for some of the instances of the specific event or field (via config switches Event Level Config Switch or Field Level Config Switch), a log message with severity {{warning}} shall be done.

                    Note: The current Trace Filter Config only allows to define trace-points on a service-type level and not on a service-instance level! If within an application multiple instances of service S are deployed, it can be a perfectly valid setup, that the Trace Filter Config has an enabled trace-point for event E of service S, but the application config only enables S.E for instance 1 and 2, but disables it for instance 3!'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }
            }

            section "Interaction_with_Generic_Trace_API" {

                /* broken_link_c/issue/18159713 */
                ScoreReq.CompReq GenericTraceApiReference {
                    description = '''{{mw::com}}/{{LoLa}} shall use the library/library API under {{/platform/aas/analysis/tracing/library/generic\_trace\_api}} to trace trace-point related information.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/19585990 */
                ScoreReq.CompReq DistinctionBetweenRecoverableAndNonRecoverableErrors {
                    description = '''All APIs provided by the Generic Trace API are returning defined error codes. Whether an error code represents a recoverable or non-recoverable error, shall be determined as follows:

                    * Error Codes of Recoverable Errors end with {{Recoverable}}

                    * Error Codes of Non-Recoverable Errors end with {{Fatal}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18159733 */
                ScoreReq.CompReq IpcTracingRegardedAsActive {
                    description = '''{{IPC Tracing}} shall be regarded as active by {{mw::com}}/{{LoLa}}, if:

                    - {{IPC Tracing}} is activated at application level (Application Level Config Switch)

                    - and a valid Trace Filter Config has been successfully processed (Processing Trace Filter Config)'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18398054 */
                ScoreReq.CompReq GlobalNonRecoverableErrorLeadsToDeactivationOfIpcTracing {
                    description = '''When any call to an API provided by {{IPC Tracing}} (i.e. any function of {{GenericTraceAPI}}) returns the global non recoverable error: {{kTerminalFatal}}, {{mw::com}}/{{LoLa}} shall deactivate {{IPC Tracing}} (i.e. {{IPC Tracing}} shall be disabled)'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1, Communication.ErrorHandling@1]
                    version = 1
                }

                /* broken_link_c/issue/18159752 */
                ScoreReq.CompReq RegisterAtIpcTracingAsAClient {
                    description = '''As soon as {{mw::com}}/{{LoLa}} runtime has determined, that {{IPC Tracing}} is active (IPC Tracing regarded as active), it shall call

                    {{static RegisterClientResult GenericTraceAPI::RegisterClient(const BindingType type, const std::string& app\_instance\_identifier)}}

                    As parameter {{type}} {{BindingType::kLoLa}} shall be used.

                    As parameter {{app\_instance\_identifier}} the configuration parameter Application Level property instance identifier shall be used.

                    If the returned {{RegisterClientResult}} contains an error, an log message with severity {{error}} shall be logged and {{IPC Tracing}} shall be disabled.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18194091 */
                ScoreReq.CompReq RegisterACallbackForTraceDoneNotification {
                    description = '''After {{mw::com}}/{{LoLa}} runtime has successfully registered as a client for {{DMA-Tracing}} (Register at IPC Tracing as a client), it shall register a callback via:

                    {{static RegisterTraceDoneCallBackResult GenericTraceAPI::RegisterTraceDoneCB(const TraceClientId client, TraceDoneCallBackType trace\_done\_callback)}}

                    As parameter {{client}} the value of the result of the successful client registration shall be used.

                    If the returned {{RegisterTraceDoneCallBackResult}} contains an error, an log message with severity error shall be logged and {{IPC Tracing}} shall be disabled.

                    Note: We estimate an error on {{RegisterTraceDoneCB}} as a non-recoverable, unexpected error.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18172251 */
                ScoreReq.CompReq MemorizeTraceClientIdOnRegistrationSuccess {
                    description = '''If the registration as a client (Register at IPC Tracing as a client) was successful, the returned {{RegisterClientResult}} contains a value of type {{TraceClientId}}.

                    It shall be stored and used for any later calls to {{GenericTraceAPI}}, which require a {{TraceClientId}} parameter.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18216878 */
                ScoreReq.CompReq TracePointTypeToMwComApiMapping {
                    description = '''The trace point types defined in {{bmw::analysis::tracing::TracePointType}} shall be mapped to {{mw::com}} APIs according to the detailed definitions of these trace points in `GenericTrace API design <broken_link_g/swh/ddad\_platform/tree/master/aas/analysis/tracing/library/design#providerskeleton-side-trace-points>`\_ '''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18217128 */
                ScoreReq.CompReq WhenToCallTrace {
                    description = '''The {{GenericTraceAPI::Trace()}} functions shall be called by {{mw::com}}/{{LoLa}} in case all following conditions are met:

                    * {{IPC Tracing}} is considered active (IPC Tracing regarded as active)

                    * A {{mw::com}} API entry point is hit, which maps to a trace point according to Trace Point Type to mw::com API mapping

                    * This trace point is {{enabled}} as per the Trace Filter Config

                    Note: Currently the Trace Filter Config (Format of Trace Filter Config) does not support the definition of service instance specific trace points! It defines trace points in the context of a service type only, which means that an {{enabled}} trace point will be hit by all service instances of a certain service type within an application using the given Trace Filter Config.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18200106 */
                ScoreReq.CompReq DefinitionOfTracePointTypesEmittingDataResidingInSharedMemory {
                    description = '''The following trace point types defined by {{bmw::analysis::tracing::TracePointType}} shall be regarded as being trace point types, where data residing in shared-memory (located in {{Typed Memory}}) is emitted:

                    * {{SKEL\_EVENT\_SND}}

                    * {{SKEL\_EVENT\_SND\_A}}

                    * {{SKEL\_FIELD\_UPD}}

                    * {{SKEL\_FIELD\_UPD\_A}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/19178261 */
                ScoreReq.CompReq TypedMemoryPreferenceForSharedMemoryObjects {
                    description = '''{{mw::com}}/{{LoLa}} shall try to create shared memory objects for DATA within {{Typed Memory}}, in case the shared memory object contains data, which shall be traced according to the current {{Trace Filter Config}}.

                    Note: This means calls to {{SharedMemoryFactory::Create()}} shall be done with parameter {{prefer\_typed\_memory}} set to {{true}}.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18166404 */
                ScoreReq.CompReq RegisterSharedMemoryObject {
                    description = '''Whenever {{mw::com}}/{{LoLa}} decides to call the {{GenericTraceAPI::Trace()}} function for a trace point emitting data (see Definition of trace point types emitting data residing in shared-memory) it shall upfront register the shared-memory object (residing in typed memory) for DATA containing data to be emitted, if all the following conditions are met:

                    * the shared-memory object was successfully located in {{typed memory}}

                    * the shared-memory object has not yet been successfully registered

                    * if it has been successfully registered, it wasn't yet unregistered again

                    with a call to:

                    {{static RegisterSharedMemoryObjectResult GenericTraceAPI::RegisterShmObject(const TraceClientId client, std::int32\_t shm\_object\_fd)}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18172406 */
                ScoreReq.CompReq IgnoringSharedMemoryObjectOnNonRecoverableError {
                    description = '''In case the registration of a shared memory object (Register a shared-memory object) failed with a non-recoverable error (see Distinction between Recoverable and Non-Recoverable Errors) a log message with severity {{warning}} shall be done and this shared-memory object shall be permanently ignored. This means, that any call to {{GenericTraceAPI::Trace}}, which would need to reference this shared-memory object shall be suppressed.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1, Communication.ErrorHandling@1]
                    version = 1
                }

                /* broken_link_c/issue/18172392 */
                ScoreReq.CompReq DeferredOnDemandRegistrationOnRecoverableError {
                    description = '''In case the registration of a shared memory object (Register a shared-memory object) failed with a recoverable error (see Distinction between Recoverable and Non-Recoverable Errors) the registration shall be retried once directly before the next {{GenericTraceAPI::Trace}} call, which needs to reference this shared-memory object.

                    If this retry still fails, the shared-memory object shall be permanently ignored. This means, that any call to {{GenericTraceAPI::Trace}}, which would need to reference this shared-memory object shall be suppressed.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1, Communication.ErrorHandling@1]
                    version = 1
                }

                /* broken_link_c/issue/18200105 */
                ScoreReq.CompReq CallTraceApiWithDataResidingInSharedMemory {
                    description = '''The following Trace API overload:

                    {{static TraceResult GenericTraceAPI::Trace(const TraceClientId client, const MetaInfoVariants::type& meta\_info, ShmDataChunkList& data, TraceContextId context\_id)}}

                    shall be called by {{mw::com}}/{{LoLa}} in case the trace point hit belongs to a data emitting trace point (see Definition of trace point types emitting data residing in shared-memory) AND this trace point is enabled as per Trace Filter Config.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18390315 */
                ScoreReq.CompReq MarkSharedMemoryDataAsInUseDuringTraceCall {
                    description = '''Note: Calls to the {{GenericTraceAPI::Trace()}} API for data residing in shared-memory (see Call Trace API with data residing in shared-memory) are asynchronous. After {{mw::com}}/{{LoLa}} has called this API, the {{IPC Tracing}} reports back via the registered "trace done" callback (see Register a callback for "trace done" notification), that tracing of the data given via a {{ShmDataChunkList}} is finished.

                    Before the call to {{GenericTraceAPI::Trace()}} with a {{ShmDataChunkList}}, {{mw::com}}/{{LoLa}} shall mark the data referenced by the {{ShmDataChunkList}} as being "in use", so that this data doesn't get overriden before {{IPC Tracing}} has reported via "trace done" callback, that the tracing has been finished.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18391193 */
                ScoreReq.CompReq ThresholdForInUseMarkingOfDataInSharedMemory {
                    description = '''Only so many data samples in shared-memory (residing in typed memory) of an event or field instance shall be marked "in use" at a time as have been configured in Event Level Config Switch or Field Level Config Switch.

                    In case a further call to {{GenericTraceAPI::Trace()}} would happen according to Call Trace API with data residing in shared-memory, but there are already all configured data samples "in use" for the very same event or field instance, which the {{ShmChunkList}} argument in the call to {{GenericTraceAPI::Trace()}} would refer to, {{mw::com}} shall skip this call to {{GenericTraceAPI::Trace()}} and set a "trace-data-loss flag" (see Global Trace-Data-Loss Flag).'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18385218 */
                ScoreReq.CompReq GeneratingTraceContextId {
                    description = '''{{mw::com}}/{{LoLa}} shall generate a {{TraceContextId}} for calls to the {{GenericTraceAPI::Trace()}} API for data residing in shared-memory (see Call Trace API with data residing in shared-memory) in a way, that this {{TraceContextId}} allows to identify the marked shared memory data (see Mark shared-memory data as "in use" during Trace() call).'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18391091 */
                ScoreReq.CompReq UnmarkSharedMemoryDataAsBeingUsedInTraceDoneCallback {
                    description = '''If {{mw::com}}/{{LoLa}} receives a call to its registered "trace done" callback (see Register a callback for "trace done" notification) with a {{TraceContextId}}, which it has previously generated (see Generating TraceContextId), it shall identify based on this {{TraceContextId}} the data in shared memory, which it has previously marked as being "in use" and unmark it again.

                    If the {{TraceContextId}} in the callback is unknown to {{mw::com}}/{{LoLa}} or has already been received and the unmarking was already done, {{mw::com}}/{{LoLa}} shall log a message with severity {{warning}}, that it has received an invalid {{TraceContextId}}.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18221771 */
                ScoreReq.CompReq CallTraceAPIWithLocalDataNotResidingInSharedMemory {
                    description = '''The following Trace API overload:

                    {{static TraceResult GenericTraceAPI::Trace(const TraceClientId client, const MetaInfoVariants::type& meta\_info, LocalDataChunkList& data)}}

                    shall be called by {{mw::com}}/{{LoLa}} in case the general conditions to call {{GenericTraceAPI::Trace()}} are met (see When to call Trace()) for the trace point being hit AND the trace point belongs NOT to a data emitting trace point (see Definition of trace point types emitting data residing in shared-memory).'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18200119 */
                ScoreReq.CompReq ParameterMetaInfoVariantUsedInTraceCalls {
                    description = '''The parameter {{meta\_info}} of type {{MetaInfoVariants::type}} in calls to {{GenericTraceAPI::Trace()}} shall be set to variant {{AraComMetaInfo}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18200787 */
                ScoreReq.CompReq UsageOfOptionalTracePointDataId {
                    description = '''The optional member {{trace\_point\_data\_id\_}} of {{AraComMetaInfo.properties\_}} shall be set in {{GenericTraceAPI::Trace()}} calls for the following trace point types:

                    * {{SKEL\_EVENT\_SND}}

                    * {{SKEL\_EVENT\_SND\_A}}

                    * {{SKEL\_FIELD\_UPD}}

                    * {{SKEL\_FIELD\_UPD\_A}}

                    * {{PROXY\_EVENT\_SAMPLE\_CB}}

                    * {{PROXY\_FIELD\_SAMPLE\_CB}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18200533 */
                ScoreReq.CompReq DetermineTracePointDataId {
                    description = '''The value used for the {{TracePointDataId}}here, shall be the timestamp of the event/field accessed in the related trace points, which is stored in the corresponding {{mw::com}}/{{LoLa}} control slot of the data.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18200709 */
                ScoreReq.CompReq DetermineTracePointIdentification {
                    description = '''The {{TracePointIdentification}} member {{trace\_point\_id\_}} of {{AraComMetaInfo.properties\_}} consists of two parts {{TracePointType}} and {{ServiceInstanceElement}}, which shall be set in every call to {{GenericTraceAPI::Trace()}} as follows:

                    * TracePointType: This shall be deduced from {{mw::com}} API context in which a trace point has been hit according to the mapping defined in Trace Point Type to mw::com API mapping

                    * ServiceInstanceElement:'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18222321 */
                ScoreReq.CompReq UsageOfShmDataChunkList {
                    description = '''The parameter {{data}} of type {{ShmDataChunkList&}} in calls to {{GenericTraceAPI::Trace()}} in the case defined in Call Trace API with data residing in shared-memory shall contain exactly one {{SharedMemoryChunk}}.

                    This {{SharedMemoryChunk}} parameter shall be set as follows:

                    * member {{start\_}} of type {{SharedMemoryLocation}}: Shall be set  to:

                      * {{shm\_object\_handle\_}} : Result of successful registration (Register a shared-memory object) of the related shared-memory object, where the data - to be traced - is located.

                      * {{offset\_}}: The offset within this shared-memory object, where the event/field related data - to be traced - starts.

                    * member {{size\_}} of type {{std::size\_t}}: Shall be set to the size of the data slot. I.e. the size of the related event or field data type.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18222516 */
                ScoreReq.CompReq UsageOfLocalDataChunkList {
                    description = '''The parameter {{data}} of type {{LocalDataChunkList&}} in calls to {{GenericTraceAPI::Trace()}} in the case of the following Trace Point Types shall contain exactly one {{LocalDataChunk}}:

                    * {{SKEL\_EVENT\_SUB}}

                    * {{SKEL\_FIELD\_SUB}}

                    * {{PROXY\_EVENT\_SUB}}

                    * {{PROXY\_EVENT\_SUBSTATE\_CHANGE }}

                    * {{PROXY\_EVENT\_CHGHDL}}

                    * {{PROXY\_FIELD\_SUB}}

                    * {{PROXY\_FIELD\_SUBSTATE\_CHANGE}}

                    * {{PROXY\_FIELD\_CHGHDL}}

                    This {{LocalDataChunk}} parameter shall be set as follows:

                    member {{start\_}} of type {{const void}} shall be set to the start address of the variable to be traced in the {{GenericTraceAPI::Trace()}} call.

                    member {{size\_}} of type {{std::size\_t}} shall be set to {{sizeof()}} value of the variable to be traced in the {{GenericTraceAPI::Trace()}} call.

                    The expected data types to be traced within a {{LocalDataChunk}} in these case of Trace Point Types shall be determined from the {{content}} column of the `Trace Point Type definition list <broken_link_g/swh/ddad\_platform/tree/master/aas/analysis/tracing/library/design#logtrace-points>`\_ .'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18228095 */
                ScoreReq.CompReq UsageOfEmptyLocalDataChunkList {
                    description = '''The following Trace Point Types shall have an empty {{LocalDataChunkList}} ({{LocalDataChunkList.Size() == 0)}}:

                    * {{SKEL\_EVENT\_UNSUB}}

                    * {{SKEL\_FIELD\_UNSUB}}

                    * {{SKEL\_FIELD\_GET\_CALL}}

                    * {{SKEL\_METHOD\_CALL}}

                    * {{PROXY\_EVENT\_UNSUB}}

                    * {{PROXY\_EVENT\_SET\_RECHDL}}

                    * {{PROXY\_EVENT\_RECHDL}}

                    * {{PROXY\_EVENT\_UNSET\_RECHDL}}

                    * {{PROXY\_EVENT\_SET\_CHGHDL}}

                    * {{PROXY\_EVENT\_UNSET\_CHGHDL}}

                    * {{PROXY\_EVENT\_GET\_SAMPLES}}

                    * {{PROXY\_EVENT\_SAMPLE\_CB}}

                    * {{PROXY\_FIELD\_UNSUB}}

                    * {{PROXY\_FIELD\_SET\_RECHDL}}

                    * {{PROXY\_FIELD\_RECHDL}}

                    * {{PROXY\_FIELD\_UNSET\_RECHDL}}

                    * {{PROXY\_FIELD\_SET\_CHGHDL}}

                    * {{PROXY\_FIELD\_UNSET\_CHGHDL}}

                    * {{PROXY\_FIELD\_GET\_SAMPLES}}

                    * {{PROXY\_FIELD\_SAMPLE\_CB}}

                    * {{PROXY\_FIELD\_SET\_RESULT}}

                    * {{PROXY\_FIELD\_GET}}

                    * {{PROXY\_FIELD\_GET\_RESULT}}

                    * {{PROXY\_METHOD\_CALL\_RESULT\_OK }}

                    * {{PROXY\_METHOD\_CALL\_RESULT\_ERROR}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                    version = 1
                }

                /* broken_link_c/issue/18398043 */
                ScoreReq.CompReq GlobalTraceDataLossFlag {
                    description = '''{{mw::com}}/{{LoLa}} shall maintain a global boolean variable, which indicates, whether an asynchronous call to {{GenericTraceAPI::Trace()}} according to Call Trace API with data residing in shared-memory had to be skipped, in order not to violate the requirement Threshold for "in use" marking of data in shared-memory.

                    Note: Reference to the underlying concept in the design of the {{Generic Trace API}} is `here <broken_link_g/swh/ddad\_platform/blob/master/aas/analysis/tracing/library/design/README.md#loss-of-trace-data>`\_ .'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18398046 */
                ScoreReq.CompReq InitValueOfTraceDataLossFlag {
                    description = '''The initial value of this flag (Global Trace-Data-Loss Flag) shall be {{FALSE}}.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18398047 */
                ScoreReq.CompReq TransmitCurrentValueOfTraceDataLossFlagInTraceCalls {
                    description = '''{{mw::com}}/{{LoLa}} shall set the current value of its global trace-data-loss flag (Global Trace-Data-Loss Flag) in the {{trace\_status\_}} member of the {{meta\_info}} argument in each call to {{GenericTraceAPI::Trace()}}.

                    The flag shall be set via method {{MetaInfoBase::SetDataLossBit()}}.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18398053 */
                ScoreReq.CompReq ResetCurrentValueOfTraceDataLossFlagAfterEachTraceCall {
                    description = '''{{mw::com}}/{{LoLa}} shall reset the current value of its global trace-data-loss flag (Global Trace-Data-Loss Flag) to {{false}} after each successful call to {{GenericTraceAPI::Trace()}}'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }

                /* broken_link_c/issue/18398059 */
                ScoreReq.CompReq NonRecoverableErrorInTraceCall {
                    description = '''In case a call to {{GenericTraceAPI::Trace()}} returns a non-recoverable error (see Distinction between Recoverable and Non-Recoverable Errors), {{mw::com}}/{{LoLa}} shall ignore the failed call to {{GenericTraceAPI::Trace()}} (i.e. shall NOT retry) and it shall:

                    * set the global trace-data-loss flag to {{true}} (Global Trace-Data-Loss Flag)

                    * deactivate the trace-point instance, which lead to the non-recoverable error and log a message with severity {{warning}} about this deactivation.

                    * increment the counter of consecutive errors (see Disable Tracing after number of consecutive Trace() errors) in {{Trace()}} calls.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1, Communication.ErrorHandling@1]
                    version = 1
                }

                /* broken_link_c/issue/18398073 */
                ScoreReq.CompReq RecoverableErrorInTraceCall {
                    description = '''In case a call to {{GenericTraceAPI::Trace()}} returns a recoverable error (see Distinction between Recoverable and Non-Recoverable Errors), {{mw::com}}/{{LoLa}} shall ignore the failed call to {{GenericTraceAPI::Trace()}} (i.e. shall NOT retry) and it shall:

                    * set the global trace-data-loss flag to {{true}} (Global Trace-Data-Loss Flag)

                    * increment the counter of consecutive errors (see Disable Tracing after number of consecutive Trace() errors) in {{Trace()}} calls.'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1, Communication.ErrorHandling@1]
                    version = 1
                }

                /* broken_link_c/issue/24726513 */
                ScoreReq.CompReq DisableTracingAfterNumberOfConsecutiveTraceErrors {
                    description = '''{{mw::com}}/{{LoLa}} shall disable IPC Tracing entirely after a configurable number of consecutive errors in calls to {{GenericTraceAPI::Trace()}}. Each successful {{GenericTraceAPI::Trace()}} call resets the consecutive error counter.

                    The error counter is incremented in these two cases:

                    * Recoverable error in Trace() call

                    * Non-recoverable error in Trace() call

                     Reasoning:


                    * A high numer of consecutive errors is a strong sign, that IPC Tracing is in a bad state (we are likely in a non-recoverable error situation)

                    * There is also some risk, that the error-paths are even more costly from runtime perspective than ok-paths. So we might stress overall ECU performance

                    * At such a point we might already have lost so much trace data, that analysis is massively hampered


                    Note:

                    Recoverable errors from GenericTraceAPI::Trace() do not necessarily indicate an issue, but might occur just due to the fact that  IPC tracking backend  has not been started (yet).

                    Hence, until it is configurable via the config file, number of consequetive errors is set to UINT32\_MAX as requested by IPC tracing feature owners'''
                    safety = ScoreReq.Asil.QM
                    derived_from = [Communication.SupportForTracing@1]
                    version = 1
                }
            }
        }

        section "Multi_Target_Build" {

            /* broken_link_c/issue/5898925 */
            ScoreReq.CompReq EnableMultiTargetBuild {
                description = '''LoLa shall be enabled for the so-called "Multi-Target-Build".

                Note:

                "Multi-Target-Build" references the possibility to alter deployment information without the need to re-compile design specifics.

                The respective adaptive AUTOSAR Requirements an be found here: Multi-Target-Build'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.DeploymentConfigurationAtRuntime@1]
                version = 1
            }

            /* broken_link_c/issue/21803701 */
            ScoreReq.CompReq ChangeOfServiceInterfaceDeployment {
                description = '''A change of the service interface deployment shall be possible without re-compiling the involved adaptive applications. â This means that the following changes in the service interface deployment shall be possible without the need for a re-compilation of the adaptive

                applications:

                * changes to the concrete type of ServiceInterfaceDeployment and the composed ServiceMethodDeployment, ServiceFieldDeployment, and ServiceEventDeployment
                 (e.g., changing a SomeipServiceInterfaceDeployment to a UserDefinedServiceInterfaceDeployment)

                * changes to one or more attributes of meta classes derived from ServiceInterfaceDeployment, ServiceMethodDeployment, ServiceFieldDeployment, and
                 ServiceEventDeployment (e.g., changing the value of SomeipEventDeployment.separationTime)'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.DeploymentConfigurationAtRuntime@1]
                version = 1
            }

            /* broken_link_c/issue/21803702 */
            ScoreReq.CompReq ChangeOfServiceInstanceDeployment {
                description = '''A change of the service instance deployment shall be possible without re-compiling the involved adaptive applications. â This means that the following changes in the service instance deployment shall be possible without the need for a re-compilation of the adaptive

                applications:

                * changes to the concrete type of ProvidedApServiceInstance and/or RequiredApServiceInstance (e.g., changing a ProvidedSomeipServiceInstance to a ProvidedUserDefinedServiceInstance and a RequiredSomeipServiceInstance to a RequiredUserDefinedServiceInstance)

                * changes to one or more attributes of meta class derived from ProvidedApServiceInstance and/or RequiredApServiceInstance (e.g., changing the value of the SomeipProvidedEventGroup.multicastThreshold
                 or the SomeipSdServerServiceInstanceConfig.serviceOfferTimeToLive).'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.DeploymentConfigurationAtRuntime@1]
                version = 1
            }
        }

        section "Partial_Restart" {

            /* broken_link_c/issue/29682823 */
            ScoreReq.CompReq ProxyAutoReconnect {
                description = '''When a {{ProxyEvent}} or {{ProxyField}} is subscribed to a {{SkeletonEvent}} or {{SkeletonField}} and the {{Skeleton}} containing the {{SkeletonEvent}} or {{SkeletonField}} stops offering and after a finite amount of time {{Skeleton}} offers again.

                Then the {{ProxyEvent}} or {{ProxyField}} shall automatically re-subscribe to the {{SkeletonEvent}} or {{SkeletonField}}.

                Note:

                This can be seen by the user by inspecting the SubscriptionState (SubscriptionState).

                This includes that all previously registered handlers (e.g. event update handler) shall still be valid.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@1]
                version = 1
            }

            /* broken_link_c/issue/31295163 */
            ScoreReq.CompReq DefinitionOfRestart {
                description = '''We define a {{restart}} as the execution of an executable as a process with a different and new POSIX PID,

                while the old POSIX PID, belonging to the execution of the same executable, is no longer valid.'''
                safety = ScoreReq.Asil.QM
                derived_from = [Communication.SupportForTimeBasedArchitecture@1]
                version = 1
            }

            /* broken_link_c/issue/29682665 */
            ScoreReq.CompReq AbilityToReinstantiateAnyProxy {
                description = '''After an application, which had

                - instantiated a valid proxy instance for a service instance provided by a different process

                - and maybe subscribed to events and/or fields of the provided service instance

                restarts, it shall be able to successfully instantiate a proxy instance for the same service instance, given that the given the service instance is still offered.

                Note:

                This shall be true for all proxies within an application.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@1, Communication.ServiceDiscovery@1]
                version = 1
            }

            /* broken_link_c/issue/31295554 */
            ScoreReq.CompReq DefinitionOfResourceNeeds {
                description = '''A service instance provider side is configured to support a given number of proxy instances with defined sample-counts in their event/field subscriptions. Therefore it reserves given resources to fulfill the communication setup demanded by this configuration'''
                safety = ScoreReq.Asil.QM
                derived_from = [Communication.ProducerConsumerPattern@1]
                version = 1
            }

            /* broken_link_c/issue/30571867 */
            ScoreReq.CompReq NoImpairmentOfCommunicationOfOtherApplications {
                description = '''A restarting {{Proxy}}, must not acquire additional resources (Definition of resource needs) on the provider side in a way, that other consumer applications might be negatively affected'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                version = 1
            }

            /* broken_link_c/issue/31295722 */
            ScoreReq.CompReq ErrorOnUnsuccessfulRestart {
                description = '''If a successful restart on the consumer side cannot be guaranteed, an {{bmw::result::Error}} containing the value {{ComErrc::kBindingFailure}} error shall be forwarded to the user in the call to {{Proxy::Create()}}.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SupportForTimeBasedArchitecture@2]
                version = 1
            }

            /* broken_link_c/issue/31295728 */
            ScoreReq.CompReq KeepUserProvidedDataValidAfterSkeletonRestart {
                description = '''After an application restarts, a skeleton shall be able to be created without .altering or invalidating user-provided data'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.SafeCommunication@1]
                version = 1
            }

            /* broken_link_c/issue/31295729 */
            ScoreReq.CompReq RecoverSubscriptionStateAfterSkeletonRestart {
                description = '''After restarting a {{Skeleton}}, the previously subscribed events/fields shall still be subscribed, including their max-sample counts.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ProducerConsumerPattern@1, Communication.EventType@1]
                version = 1
            }

            /* broken_link_c/issue/31295733 */
            ScoreReq.CompReq RecoverSubscriptionCapacityAfterSkeletonRestart {
                description = '''After restarting a {{Skeleton}}, it shall have the same capacity for new subscribers like it had before the restart.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ProducerConsumerPattern@1, Communication.EventType@1]
                version = 1
            }

            /* broken_link_c/issue/31295746 */
            ScoreReq.CompReq RecoverAllocatableSamplesAfterSkeletonRestart {
                description = '''After restarting a {{Skeleton}}, it shall be able to allocate the configured amount of {{SampleAllocateePtr}} as before the restart.'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ZeroCopy@1]
                version = 1
            }

            /* broken_link_c/issue/31295752 */
            ScoreReq.CompReq RecoverHandlersAfterSkeletonRestart {
                description = '''After restarting a skeleton, all previously registered handlers shall still be functional.

                Note: Possible handlers are: {{EventUpdateNotificationHandler}}, {{SubscriptionStateChangeHandler}}'''
                safety = ScoreReq.Asil.B
                derived_from = [Communication.ProducerConsumerPattern@1, Communication.EventType@1]
                version = 1
            }
        }
    }
}
